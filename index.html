
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Anjuke Engineering</title>
  <meta name="author" content="Anjuke Inc.">

  
  <meta name="description" content="RVM是Ruby Version Manager的缩写，是管理Ruby版本的工具，方便在开发、部署的时候于多个Ruby环境中切换与使用 关于RVM的信息，请参考官方网站的最新资料为准 ">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://arch.corp.anjuke.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Anjuke Engineering" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-38932031-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Anjuke Engineering</a></h1>
  
    <h2>技术成就梦想</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:arch.corp.anjuke.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="https://github.com/anjuke">Code</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/13/rvm-tutorial/">RVM Tutorial</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-13T11:30:00+08:00" pubdate data-updated="true">May 13<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>RVM是Ruby Version Manager的缩写，是管理Ruby版本的工具，方便在开发、部署的时候于多个Ruby环境中切换与使用</p>

<p>关于RVM的信息，请参考<a href="https://rvm.io">官方网站</a>的最新资料为准</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/05/13/rvm-tutorial/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/13/a-brief-introduction-to-ssh/">A Brief Introduction to SSH</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-13T10:53:00+08:00" pubdate data-updated="true">May 13<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>为什么会有这篇介绍？</h2>

<p>不少人对ssh有疑问或者不明白，典型的例子是在gitcorp/github上添加了公钥后发现无法clone或者push仓库里的代码。</p>

<h2>前言</h2>

<p>ssh是个很大的话题，会发现牵涉到unix-like下很多东西，这里只谈谈我们日常工作中接触最多的那部分</p>

<p>哦，对了，这里的ssh不是Java里的SSH（Spring/Structs/Hibernate）。我也是前几天刚明白XDD</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.eng.cam.ac.uk/help/jpmg/ssh/ssh-detail.html">ssh - how it works</a></li>
<li><a href="http://en.wikipedia.org/wiki/Secure_Shell">Secure Shell</a></li>
<li><a href="http://www.unixwiz.net/techtips/ssh-agent-forwarding.html">An Illustrated Guide to SSH Agent Forwarding</a></li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/05/13/a-brief-introduction-to-ssh/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/09/beautiful-computer-programming/">Beautiful Computer Programming</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-04-09T20:49:00+08:00" pubdate data-updated="true">Apr 9<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>We have seen that computer programming is an art, because it applies accumulated knowledge to the world, because it requires skill and ingenuity, and especially because it produces objects of beauty. A programmer who subconsciously views himself as an artist will enjoy what he does and will do it better. Therefore we can be glad that people who lecture at computer conferences speak about the state of the Art.</p></blockquote>

<p><a href="http://www.paulgraham.com/knuth.html">Computer Programming as an Art</a>。</p>

<h2>美</h2>

<p>毫无疑问，如果计算机程序作为艺术品首先要美。美包括多个方面，程序运行时呈现的界面要漂亮；文档要美观；很重要的，代码本身也要看着舒服。</p>

<p>对于工程师来说，我们接触最多的是代码本身。当我们看书法作品时，首先看到的是整篇文字，这里面的排版，字体的大小，间隔的分布都将影响到整个作品的美观程度。然后才是一个个具体的字。</p>

<p>那么代码也是首先需要有合理的排版，与文本的文字一样，</p>

<ul>
<li><strong>需要有的合理顺序</strong><br/>
能够顺序阅读的代码是最舒服的</li>
<li><strong>段落之间要留有适当空白</strong></li>
<li><strong>指令之间以适当的空格分割</strong></li>
<li><strong>正确的缩进</strong></li>
<li><strong>一行代码不应该太宽</strong><br/>
如果超出屏幕的显示宽度，肯定影响了阅读体验。折行的显示也损害了代码的美观度，尤其是在需要打印输出的情况下。</li>
</ul>


<p>在计算机程序中，我们会对各种标示符进行命名，例如变量名、函数名、类名等等。对这些标示符的命名，应当采用<strong>简单明确</strong>的原则。能否看到名称就能够知道其意图是一个很好的衡量方式。同时也应当避免过度冗长的名称，因为这样既显得无意义，也降低了代码的美观度。</p>

<p>另外，拼写错误的名称将极大影响代码的美观。</p>

<p>优秀的代码应该能够清晰地表达自己的意图，这样的代码能够自我解释，不需要有冗余的注释。对一些特别的实现，代码本身难以表达的，才加上注释。</p>

<p>计算机程序最终呈现出来的界面也要美观。这里包括了与用户交互的界面(UI)；与其他程序交互的编程接口(API)。</p>

<hr />

<p>美观的代码对工程师是一个基础要求。</p>

<p>要写出美的程序，工程师必须是一个爱美的人。可以看他的开发工具是不是很美，编辑器里的字体是否漂亮，色彩搭配很美。很难想象一个用着糟糕字体编辑器的工程师能够写出美的代码。</p>

<h2>酷</h2>

<p>酷是创造性的东西，是很特别的，与众不同的。酷的程序往往来自于创新，采用了一个与传统方式不同，却非常有效的方法解决了问题。</p>

<p>你的程序如果真的很酷，很快就会有各种模仿者。</p>

<hr />

<p>具有激情，乐于尝试新东西的工程师才能够做出酷的东西来。这样的工程师，总觉得目前的实现不够好，还能够更好，并努力尝试新的方法。</p>

<h2>优雅</h2>

<p>对于一个功能，计算机程序可以采用多种方式实现，虽然他们的结果可能一致，但是实现方式确可能有好有坏。这可以表现在程序执行的性能、需要占用的资源等方面，甚至代码的行数。一个排序方法，使用不同的算法，性能的差异可以是天差地别。优雅的代码应该采用简单合理的数据结构、算法和设计模式。</p>

<p>优雅很大程度上体现在对计算机程序的设计上，尤其是在需要多个程序相互协同工作的系统设计时，优雅的设计和糟糕的设计将有很大的区别。</p>

<p>其实优雅的代码和设计对人也是友好的。能够让阅读代码的人感到愉悦，充分理解代码的意图。</p>

<hr />

<p>做出优雅设计的工程师必须拥有丰富的编程经验。在经历了非常多的代码和设计之后，善于总结和学习的工程师逐渐掌握了方法，能够在优雅的设计和糟糕的设计之间做出正确的选择。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/28/perl-prime-in-action-jvm-monitoring-2/">Perl入门实战：JVM监控脚本（下）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-28T15:28:00+08:00" pubdate data-updated="true">Mar 28<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>套接字</h2>

<p>使用套接字（Socket）进行网络通信的基本流程是：</p>

<ul>
<li>服务端：监听端口、等待连接、接收请求、发送应答；</li>
<li>客户端：连接服务端、发送请求、接收应答。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='perl'><span class='line'><span class="k">use</span> <span class="nn">IO::Socket::</span><span class="n">INET</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">my</span> <span class="nv">$server</span> <span class="o">=</span> <span class="nn">IO::Socket::</span><span class="n">INET</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span>
</span><span class='line'>    <span class="n">LocalPort</span> <span class="o">=&gt;</span> <span class="mi">10060</span><span class="p">,</span>
</span><span class='line'>    <span class="n">Type</span> <span class="o">=&gt;</span> <span class="n">SOCK_STREAM</span><span class="p">,</span>
</span><span class='line'>    <span class="n">Reuse</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>    <span class="n">Listen</span> <span class="o">=&gt;</span> <span class="n">SOMAXCONN</span>
</span><span class='line'><span class="p">)</span> <span class="o">||</span> <span class="nb">die</span> <span class="s">&quot;服务创建失败\n&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$client</span> <span class="o">=</span> <span class="nv">$server</span><span class="o">-&gt;</span><span class="nb">accept</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">my</span> <span class="nv">$line</span> <span class="o">=</span> <span class="sr">&lt;$client&gt;</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">chomp</span><span class="p">(</span><span class="nv">$line</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=~</span><span class="sr"> /^JVMPORT ([0-9]+)$/</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;RECV $1\n&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">print</span> <span class="nv">$client</span> <span class="s">&quot;OK\n&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;ERROR $line\n&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">print</span> <span class="nv">$client</span> <span class="s">&quot;ERROR\n&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">close</span><span class="p">(</span><span class="nv">$client</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nb">close</span><span class="p">(</span><span class="nv">$server</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/03/28/perl-prime-in-action-jvm-monitoring-2/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/27/fork-and-zombie-process/">Fork()与僵尸进程</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-27T20:18:00+08:00" pubdate data-updated="true">Mar 27<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>使用fork()函数派生出多个子进程来并行执行程序的不同代码块，是一种常用的编程泛型。特别是在网络编程中，父进程初始化后派生出指定数量的子进程，共同监听网络端口并处理请求，从而达到扩容的目的。</p>

<p>但是，在使用fork()函数时若处理不当，很容易产生僵尸进程。根据UNIX系统的定义，僵尸进程是指子进程退出后，它的父进程没有“等待”该子进程，这样的子进程就会成为僵尸进程。何谓“等待”？僵尸进程的危害是什么？以及要如何避免？这就是本文将要阐述的内容。</p>

<h2>fork()函数</h2>

<p>下面这段C语言代码展示了fork()函数的使用方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// myfork.c</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 主进程</span>
</span><span class='line'>            <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 子进程</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;fork error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/03/27/fork-and-zombie-process/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/26/perl-prime-in-action-jvm-monitoring-1/">Perl入门实战：JVM监控脚本（上）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-26T23:00:00+08:00" pubdate data-updated="true">Mar 26<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>由于最近在搭建Zabbix监控服务，需要制作各类监控的模板，如iostat、Nginx、MySQL等，因此会写一些脚本来完成数据采集的工作。又因为近期对Perl语言比较感兴趣，因此决定花些时间学一学，写一个脚本来练练手，于是就有了这样一份笔记。</p>

<h2>需求描述</h2>

<p>我们将编写一个获取JVM虚拟机状态信息的脚本：</p>

<ol>
<li>启动一个服务进程，通过套接字接收形如“JVMPORT 2181”的请求；</li>
<li>执行<code>netstat</code>命令，根据端口获取进程号；</li>
<li>执行<code>jstat</code>命令获取JVM的GC信息；<code>jstack</code>获取线程信息；<code>ps -o pcpu,rss</code>获取CPU和内存使用情况；</li>
<li>将以上信息返回给客户端；</li>
</ol>


<p>之所以需要这样一个服务是因为Zabbix Agent会运行在zabbix用户下，无法获取运行在其他用户下的JVM信息。</p>

<p>此外，Zabbix Agent也需要编写一个脚本来调用上述服务，这个在文章末尾会给出范例代码。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/03/26/perl-prime-in-action-jvm-monitoring-1/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/07/currying-and-partial-application/">柯里化与偏应用（JavaScript描述）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-07T20:59:00+08:00" pubdate data-updated="true">Mar 7<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文：<a href="http://raganwald.com/2013/03/07/currying-and-partial-application.html">http://raganwald.com/2013/03/07/currying-and-partial-application.html</a></p>

<p>上周末我参加了<a href="http://wrocloverb.com/">wroc_love.rb大会</a>，其间<a href="http://steveklabnik.com/">Steve Klabnik</a>的一张PPT中提到了<a href="https://en.wikipedia.org/wiki/Partial_application">偏应用（Partial Application）</a>和<a href="https://en.wikipedia.org/wiki/Currying">柯里化（Currying）</a>，并说这两者之间的区别如今已经不重要了。但是我不这么认为。</p>

<p>在这周发布的博文中，我用五种方式对<code>this</code>和闭包做了解释，但只有三到四种提到了柯里化。所以这篇博文就重点来谈谈这个。</p>

<h2>函数参数的个数</h2>

<p>在讲解之前，我们先明确一些术语。函数定义时会写明它所接收的参数个数（Arity）。“一元函数”（Unary）接收一个参数，“多元函数”（Polyadic）接收多个参数。还有一些特殊的名称，如“二元函数”（Binary）接收两个参数，“三元函数”（Ternary）接收三个参数等。你可以对照希腊语或拉丁语词汇来创造这些特殊的名称。</p>

<p>有些函数能够接收不定数量的参数，我们称之为“可变参数函数”（Variadic）。不过这类函数、以及不接收参数的函数并不是本文讨论的重点。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/03/07/currying-and-partial-application/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/01/using-pypi-provided-by-anjuke/">使用安居客提供的PyPI镜像</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-01T10:52:00+08:00" pubdate data-updated="true">Mar 1<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>主要提示：安居客现在拥有了自己的PyPI镜像，直接使用http://pypi.corp.anjuke.com/simple ，就可以节省重复去公网下载模块的流量与时间。</p>

<h2>Welcome to the Python World!</h2>

<p>这篇文章的目标读者是还刚接触Python以及安居客将要使用Python的各位开发者，强烈建议把文中提到的延伸信息都阅读一下，百利无害。</p>

<p>使用Python开发程序是一件轻松惬意的事情，它的第三方模块分发机制让开发者能够很方便快速的发布自己的代码、安装部署使用其他开发者做的模块。（详细请参考<a href="http://docs.python.org/2/install/index.html">安装Python模块</a>，<a href="http://docs.python.org/2/distutils/index.html">发布Python模块</a>）</p>

<p>关于Python打包的方式以及开源软加架构里打包的背景信息，可以阅读<a href="http://www.ituring.com.cn/article/19090">这篇内容</a>了解更多。</p>

<h2>如何安装第三方的Python模块</h2>

<p>标准的Python模块源码包里都会带上一个<code>setup.py</code>，它是Python的模块分发机制中的一部分，其中会定义模块的基本信息以及 <strong>依赖</strong> ，后者就是我们重点需要关注的问题。</p>

<p>通常我们只需要执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>python setup.py install</span></code></pre></td></tr></table></div></figure>


<p>即可完成安装。</p>

<h2>Python模块的分发</h2>

<p>传统模块的分发如果采用原始的人肉方式那就显得不够好了；所以Python社区有了PyPI（Python Package Index），官方的地址是<a href="https://pypi.python.org">pypi.python.org</a>，全世界各地还有几个<a href="http://www.pypi-mirrors.org">镜像</a>；以及配套使用的客户端程序，<code>setuptools</code>和<code>pip</code></p>

<p><strong>我们建议使用<code>pip</code></strong></p>

<p>前者一般在Python安装的时候随同一起分发，后者需要手工安装（<code>pythonbrew</code>里则是会自动一起安装）</p>

<p>对于想要使用的模块依赖，使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>easy_install foobar
</span><span class='line'>
</span><span class='line'>#或者
</span><span class='line'>pip install foobar</span></code></pre></td></tr></table></div></figure>


<p>它的过程就像是ubuntu下的<code>apt-get</code>，自动从配置的镜像（默认是官方）自动查找目标模块，下载，（编译）安装，整个过程轻松简单。</p>

<h2>为什么我们要提供安居客的镜像</h2>

<p>出于安居客未来架构发展的需要，我们在开发、生产环境的部署将会更多的采用自动化；项目的依赖是其中一个不可忽视的环节。对于Python来说，快速高效地安装依赖能提高效率，减少错误。</p>

<p>还有一点是，每次安装都从官方下载会造成流量和时间的浪费；更多的，因为某些大家都懂的原因造成一个项目依赖无法安装，很令人恼火。做镜像提高速度，减少问题也是让工程师快乐的一个体现。</p>

<h2>如何使用安居客的PyPI镜像</h2>

<p><strong>更详细的使用方法请参考<code>easy_install</code>和<code>pip</code>的文档</strong></p>

<h3>安装 (install)</h3>

<ul>
<li>easy_install</li>
</ul>


<p>直接使用easy_install的命令，带上参数指定</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>easy_install -i http://pypi.corp.anjuke.com/simple FOOBAR</span></code></pre></td></tr></table></div></figure>


<p>或者写配置文件<code>~/.pydistutils.cfg</code>，内容如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[easy_install]
</span><span class='line'>index_url = http://pypi.corp.anjuke.com/simple</span></code></pre></td></tr></table></div></figure>


<ul>
<li>pip</li>
</ul>


<p>直接使用pip命令，带上参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip -i http://pypi.corp.anjuke.com/simple install FOOBAR</span></code></pre></td></tr></table></div></figure>


<p>或者写配置文件<code>~/.pip/pip.conf</code>，内容如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[global]
</span><span class='line'>index-url = http://pypi.corp.anjuke.com/simple</span></code></pre></td></tr></table></div></figure>


<h3>搜索 (search)</h3>

<p><strong>暂未支持</strong></p>

<h2>最后</h2>

<p>我们希望为工程师、开发者提供更好的环境来支持开发工作。</p>

<p>如果大家在使用中有各种问题，意见和建议，欢迎联系我们。</p>

<p>Happy Hacking ;)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/09/cia-hadoop/">Clojure实战(4)：编写Hadoop MapReduce脚本</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-09T16:43:00+08:00" pubdate data-updated="true">Feb 9<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Hadoop简介</h2>

<p>众所周知，我们已经进入了大数据时代，每天都有PB级的数据需要处理、分析，从中提取出有用的信息。Hadoop就是这一时代背景下的产物。它是Apache基金会下的开源项目，受<a href="http://en.wikipedia.org/wiki/Apache_Hadoop#Papers">Google两篇论文</a>的启发，采用分布式的文件系统HDFS，以及通用的MapReduce解决方案，能够在数千台物理节点上进行分布式并行计算。</p>

<p>对于Hadoop的介绍这里不再赘述，读者可以<a href="http://hadoop.apache.org/">访问其官网</a>，或阅读<a href="http://product.dangdang.com/main/product.aspx?product_id=21127813">Hadoop权威指南</a>。</p>

<p>Hadoop项目是由Java语言编写的，运行在JVM之上，因此我们可以直接使用Clojure来编写MapReduce脚本，这也是本文的主题。Hadoop集群的搭建不在本文讨论范围内，而且运行MapReduce脚本也无需搭建测试环境。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/02/09/cia-hadoop/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/20/homebrew-is-just-like-gentoo-portage/">Homebrew Is Just Like Gentoo Portage</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-20T14:28:00+08:00" pubdate data-updated="true">Jan 20<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="right" src="http://0.gravatar.com/avatar/ce1e13bbf946c92e2abf740f8909bafa"></p>

<h2>一句话提示：</h2>

<blockquote><p>利用<code>brew versions</code>和<code>brew switch</code>命令也可以实现gentoo portage里eselect类似的版本切换功能!</p></blockquote>

<p>老规矩，喜欢听故事的继续看下去XDDD</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/01/20/homebrew-is-just-like-gentoo-portage/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/05/13/rvm-tutorial/">RVM Tutorial</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/13/a-brief-introduction-to-ssh/">A Brief Introduction to SSH</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/04/09/beautiful-computer-programming/">Beautiful Computer Programming</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/28/perl-prime-in-action-jvm-monitoring-2/">Perl入门实战：JVM监控脚本（下）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/27/fork-and-zombie-process/">fork()与僵尸进程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/26/perl-prime-in-action-jvm-monitoring-1/">Perl入门实战：JVM监控脚本（上）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/07/currying-and-partial-application/">柯里化与偏应用（JavaScript描述）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/01/using-pypi-provided-by-anjuke/">使用安居客提供的PyPI镜像</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/09/cia-hadoop/">Clojure实战(4)：编写Hadoop MapReduce脚本</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/20/homebrew-is-just-like-gentoo-portage/">Homebrew is just like gentoo portage</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/anjuke">@anjuke</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'anjuke',
            count: 10,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Anjuke Inc. -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'archcorp';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
