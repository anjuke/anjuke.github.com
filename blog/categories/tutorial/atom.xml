<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tutorial | Anjuke Engineering]]></title>
  <link href="http://arch.corp.anjuke.com/blog/categories/tutorial/atom.xml" rel="self"/>
  <link href="http://arch.corp.anjuke.com/"/>
  <updated>2014-05-16T12:00:48+08:00</updated>
  <id>http://arch.corp.anjuke.com/</id>
  <author>
    <name><![CDATA[Anjuke Inc.]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Perl入门实战：JVM监控脚本（下）]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2013/03/28/perl-prime-in-action-jvm-monitoring-2/"/>
    <updated>2013-03-28T15:28:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2013/03/28/perl-prime-in-action-jvm-monitoring-2</id>
    <content type="html"><![CDATA[<h2>套接字</h2>

<p>使用套接字（Socket）进行网络通信的基本流程是：</p>

<ul>
<li>服务端：监听端口、等待连接、接收请求、发送应答；</li>
<li>客户端：连接服务端、发送请求、接收应答。</li>
</ul>


<p>```perl
use IO::Socket::INET;</p>

<p>my $server = IO::Socket::INET->new(</p>

<pre><code>LocalPort =&gt; 10060,
Type =&gt; SOCK_STREAM,
Reuse =&gt; 1,
Listen =&gt; SOMAXCONN
</code></pre>

<p>) || die "服务创建失败\n";</p>

<p>while (my $client = $server->accept()) {</p>

<pre><code>my $line = &lt;$client&gt;;
chomp($line);

if ($line =~ /^JVMPORT ([0-9]+)$/) {
    print "RECV $1\n";
    print $client "OK\n";
} else {
    print "ERROR $line\n";
    print $client "ERROR\n";
}

close($client);
</code></pre>

<p>}</p>

<p>close($server);
```</p>

<!--more-->


<ul>
<li><code>IO::Socket::INET</code>是一个内置模块，<code>::</code>符号用来分隔命名空间。</li>
<li><code>-&gt;new</code>运算符是用来创建一个类的实例的，这涉及到面向对象编程，我们暂且忽略。</li>
<li><code>(key1 =&gt; value1, key2 =&gt; value2)</code>是用来定义一个哈希表的，也就是键值对。这里是将哈系表作为参数传递给了<code>new</code>函数。请看以下示例。对于哈系表的进一步操作，我们这里暂不详述。</li>
</ul>


<p>```perl
sub hello {</p>

<pre><code>my %params = @_;
print "Hello, $params{'name'}!\n";
</code></pre>

<p>}</p>

<p>hello('name' => 'Jerry'); # 输出 Hello, Jerry!
```</p>

<ul>
<li><code>while (...) {...}</code>是另一种循环结构，当圆括号的表达式为真就会执行大括号中的语句。</li>
<li><code>$server-&gt;accept()</code>表示调用<code>$server</code>对象的<code>accept()</code>函数，用来接受一个连接。执行这个函数时进程会阻塞（进入睡眠），当有连接过来时才会唤醒，并将该连接赋值给<code>$client</code>变量。</li>
<li><code>&lt;...&gt;</code>运算符表示从文件中读取一行，如：</li>
</ul>


<p>```perl
open my $fd, '&lt;', '/proc/diskstats';
while (my $line = &lt;$fd>) {</p>

<pre><code>print $line;
</code></pre>

<p>}
```</p>

<p>由于套接字也可以作为文件来看待，所以就能使用<code>&lt;...&gt;</code>运算符。关于<code>open</code>函数和其他文件操作，读者可参考<a href="http://perl5maven.com/open-and-read-from-files">这篇文章</a>。</p>

<ul>
<li><code>chomp()</code>函数用来将字符串末尾的换行符去掉。它的用法也比较奇特，不是<code>$line = chomp($line)</code>，而是<code>chomp($line)</code>，这里<code>$line</code>是一次引用传递。</li>
<li>细心的读者会发现，第二句<code>print</code>增加了<code>$client</code>，可以猜到它是用来指定<code>print</code>的输出目标。默认情况下是标准输出。</li>
</ul>


<p>我们打开两个终端，一个终端执行服务端，另一个终端直接用Bash去调用。</p>

<p>```bash</p>

<h1>客户端</h1>

<p>$ echo 'JVMPORT 2181' | nc 127.0.0.1 10060
OK
$ echo 'hello' | nc 127.0.0.1 10060
ERROR</p>

<h1>服务端</h1>

<p>$ ./socket-server.pl
RECV 2181
ERROR hello
```</p>

<p>至于客户端，还请读者自行完成，可参考<a href="http://perldoc.perl.org/IO/Socket/INET.html">相关文档</a>。</p>

<h2>子进程</h2>

<p>上述代码中有这样一个问题：当客户端建立了连接，但迟迟没有发送内容，那么服务端就会阻塞在<code>$line = &lt;$client&gt;</code>这条语句，无法接收其他请求。有三种解决方案：</p>

<ol>
<li>服务端读取信息时采用一定的超时机制，如果3秒内还不能读到完整的一行就断开连接。可惜Perl中并没有提供边界的方法来实现这一机制，需要自行使用<code>IO::Select</code>这样的模块来编写，比较麻烦。</li>
<li>接受新的连接后打开一个子进程或线程来处理连接，这样就不会因为一个连接挂起而使整个服务不可用。</li>
<li>使用非阻塞事件机制，当有读写操作时才会去处理。</li>
</ol>


<p>这里我们使用第二种方案，即打开子进程来处理请求。</p>

<p>```perl
use IO::Socket::INET;</p>

<p>sub REAPER {</p>

<pre><code>my $pid;
while (($pid = waitpid(-1, 'WNOHANG')) &gt; 0) {
    print "SIGCHLD $pid\n";
}
</code></pre>

<p>}</p>

<p>my $interrupted = 0;
sub INTERRUPTER {</p>

<pre><code>$interrupted = 1;
</code></pre>

<p>}</p>

<p>$SIG{CHLD} = &amp;REAPER;
$SIG{TERM} = &amp;INTERRUPTER;
$SIG{INT} = &amp;INTERRUPTER;</p>

<p>my $server = ...;</p>

<p>while (!$interrupted) {</p>

<pre><code>if (my $client = $server-&gt;accept()) {

    my $pid = fork();

    if ($pid &gt; 0) {
        close($client);
        print "PID $pid\n";
    } elsif ($pid == 0) {
        close($server);

        my $line = &lt;$client&gt;;
        ...
        close($client);
        exit;

    } else {
        print "fork()调用失败\n";
    }
}
</code></pre>

<p>}</p>

<p>close($server);
```</p>

<p>我们先看下半部分的代码。系统执行<code>fork()</code>函数后，会将当前进程的所有内容拷贝一份，以新的进程号来运行，即子进程。通过<code>fork()</code>的返回值可以知道当前进程是父进程还是子进程：大于0的是父进程；等于0的是子进程。子进程中的代码做了省略，执行完后直接<code>exit</code>。</p>

<p>上半部分的信号处理是做什么用的呢？这就是在多进程模型中需要特别注意的问题：僵尸进程。具体可以参考<a href="http://shzhangji.com/blog/2013/03/27/fork-and-zombie-process/">这篇文章</a>。</p>

<p>而<code>$interrupted</code>变量则是用来控制程序是否继续执行的。当进程收到<code>SIGTERM</code>或<code>SIGINT</code>信号时，该变量就会置为真，使进程自然退出。</p>

<p>为何不直接使用<code>while (my $client = $server-&gt;accept()) {...}</code>呢？因为子进程退出时会向父进程发送<code>SIGCHLD</code>信号，而<code>accept()</code>函数在接收到任何信号后都会中断并返回空，使得<code>while</code>语句退出。</p>

<h2>命令行参数</h2>

<p>这个服务脚本所监听的端口后是固写在脚本中的，如果想通过命令行指定呢？我们可以使用Perl的内置模块<code>Getopt::Long</code>。</p>

<p>```perl
use Getopt::Long;
use Pod::Usage;</p>

<p>my $help = 0;
my $port = 10060;</p>

<p>GetOptions(</p>

<pre><code>'help|?' =&gt; \$help,
'port=i' =&gt; \$port
</code></pre>

<p>) || pod2usage(2);
pod2usage(1) if $help;</p>

<p>print "PORT $port\n";</p>

<p><strong>END</strong></p>

<p>=head1 NAME</p>

<p>getopt</p>

<p>=head1 SYNOPSIS</p>

<p>getopt.pl [options]</p>

<p> Options:
   -help brief help message
   -port bind to tcp port</p>

<p>=cut
```</p>

<p>使用方法是：</p>

<p>```bash
$ ./getopt.pl -h
Usage:</p>

<pre><code>getopt.pl [options]
...
</code></pre>

<p>$ ./getopt.pl
PORT 10060
$ ./getopt.pl -p 12345
PORT 12345
```</p>

<p><code>'port=i' =&gt; \$port</code>表示从命令行中接收名为<code>-port</code>的参数，并将接收到的值转换为整数（<code>i</code>指整数）。<code>\$</code>又是一种引用传递了，这里暂不详述。</p>

<p>至于<code>||</code>运算符，之前在建立<code>$server</code>时也遇到过，它实际上是一种逻辑运算符，表示“或”的关系。这里的作用则是“如果GetOptions返回的值不为真，则程序退出”。</p>

<p><code>pod2usage(1) if $help</code>表示如果<code>$help</code>为真则执行<code>pod2usage(1)</code>。你也可以写为<code>$help &amp;&amp; pod2usage(1)</code>。</p>

<p>我们再来看看<code>__END__</code>之后的代码，它是一种Pod文档（Plain Old Documentation），可以是单独的文件，也可以像这样直接附加到Perl脚本末尾。具体格式可以参考<a href="http://perldoc.perl.org/perlpod.html">perlpod</a>。<code>pod2usage()</code>函数顾名思义是将附加的Pod文档转化成帮助信息显示在控制台上。</p>

<h2>小结</h2>

<p>完整的脚本可以见这个链接<a href="https://github.com/jizhang/zabbix-templates/blob/master/jvm/jvm-service.pl">jvm-service.pl</a>。调用该服务的脚本可以见<a href="https://github.com/jizhang/zabbix-templates/blob/master/jvm/jvm-check.pl">jvm-check.pl</a>。</p>

<p>Perl语言历史悠久，语法丰富，还需多使用、多积累才行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl入门实战：JVM监控脚本（上）]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2013/03/26/perl-prime-in-action-jvm-monitoring-1/"/>
    <updated>2013-03-26T23:00:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2013/03/26/perl-prime-in-action-jvm-monitoring-1</id>
    <content type="html"><![CDATA[<p>由于最近在搭建Zabbix监控服务，需要制作各类监控的模板，如iostat、Nginx、MySQL等，因此会写一些脚本来完成数据采集的工作。又因为近期对Perl语言比较感兴趣，因此决定花些时间学一学，写一个脚本来练练手，于是就有了这样一份笔记。</p>

<h2>需求描述</h2>

<p>我们将编写一个获取JVM虚拟机状态信息的脚本：</p>

<ol>
<li>启动一个服务进程，通过套接字接收形如“JVMPORT 2181”的请求；</li>
<li>执行<code>netstat</code>命令，根据端口获取进程号；</li>
<li>执行<code>jstat</code>命令获取JVM的GC信息；<code>jstack</code>获取线程信息；<code>ps -o pcpu,rss</code>获取CPU和内存使用情况；</li>
<li>将以上信息返回给客户端；</li>
</ol>


<p>之所以需要这样一个服务是因为Zabbix Agent会运行在zabbix用户下，无法获取运行在其他用户下的JVM信息。</p>

<p>此外，Zabbix Agent也需要编写一个脚本来调用上述服务，这个在文章末尾会给出范例代码。</p>

<!-- more -->


<h2>Hello, world!</h2>

<p>还是要不免俗套地来一个helloworld，不过我们的版本会稍稍丰富些：</p>

<p>```perl</p>

<h1>!/usr/bin/perl</h1>

<p>use strict;
my $name = 'Jerry';
print "Hello, $name!\n"; # 输出 Hello, Jerry!
```</p>

<p>将该文件保存为<code>hello.pl</code>，可以用两种方式执行：</p>

<p><code>bash
$ perl hello.pl
Hello, Jerry!
$ chmod 755 hello.pl
$ ./hello.pl
Hello, Jerry!
</code></p>

<ul>
<li>所有的语句都以分号结尾，因此一行中可以有多条语句，但并不提倡这样做。</li>
<li><code>use</code>表示加载某个模块，加载<a href="http://search.cpan.org/~rjbs/perl-5.16.3/lib/strict.pm"><code>strict</code>模块</a>表示会对当前文件的语法做出一些规范和约束。比如将<code>my $name ...</code>前的<code>my</code>去掉，执行后Perl解释器会报错。建议坚持使用该模块。</li>
<li><code>$name</code>，一个Perl变量。<code>$</code>表示该变量是一个标量，可以存放数值、字符串等基本类型。其它符号有<code>@</code>和<code>%</code>，分别对应数组和哈希表。</li>
<li><code>my</code>表示声明一个变量，类似的有<code>our</code>、<code>local</code>等，将来接触到变量作用域时会了解。</li>
<li>字符串可以用单引号或双引号括起来，区别是双引号中的变量会被替换成实际值以及进行转移，单引号则不会。如<code>'Hello, $name!\n'</code>中的<code>$name</code>和<code>\n</code>会按原样输出，而不是替换为“Jerry”和换行符。</li>
<li><code>print</code>语句用于将字符串输出到标准输出上。</li>
<li><code>#</code>表示注释。</li>
</ul>


<h2>正则表达式</h2>

<p>我们第一个任务是从“JVMPORT 2181”这样的字符串中提取“2181”这个端口号。解决方案当然是使用正则，而且Perl的强项之一正是文本处理：</p>

<p>```perl
my $line = 'JVMPORT 2181';
if ($line =~ /<sup>JVMPORT</sup> ([0-9]+)$/) {</p>

<pre><code>print $1, "\n"; # 输出 2181
</code></pre>

<p>} else {</p>

<pre><code>print '匹配失败', "\n";
</code></pre>

<p>}
```</p>

<p>这里假设你知道如何使用正则表达式。</p>

<ul>
<li><code>=~</code>运算符表示将变量和正则表达式进行匹配，如果匹配成功则返回真，失败则返回假。</li>
<li>匹配成功后，Perl会对全局魔术变量——<code>$0</code>至<code>$9</code>进行赋值，分别表示正则表达式完全匹配到的字符串、第一个子模式匹配到的字符串、第二个子模式，依此类推。</li>
<li><code>if...else...</code>是条件控制语句，其中<code>...} else if (...</code>可以简写为<code>...} elsif (...</code>。</li>
</ul>


<h2>调用命令行</h2>

<p>使用反引号（即大键盘数字1左边的按键）：</p>

<p><code>perl
my $uname = `uname`;
print $uname; # 输出 Linux
my $pid = '1234';
$line = `ps -ef | grep $pid`; # 支持管道符和变量替换
</code></p>

<p>对于返回多行结果的命令，我们需要对每一行的内容进行遍历，因此会使用数组和<code>foreach</code>语句：</p>

<p><code>``perl
my $pid;
my $jvmport = '2181';
my @netstat =</code>netstat -lntp 2>/dev/null`;
foreach my $line (@netstat) {</p>

<pre><code>if ($line =~ /.*?:$jvmport\s.*?([0-9]+)\/java\s*$/) {
    $pid = $1;
    last;
}
</code></pre>

<p>}
if ($pid) {</p>

<pre><code>print $pid, "\n";
</code></pre>

<p>} else {</p>

<pre><code>print '端口不存在', "\n";
</code></pre>

<p>}
```</p>

<ul>
<li><code>$pid</code>变量的结果是2181端口对应的进程号。</li>
<li>这个正则可能稍难理解，但对照<code>netstat</code>的输出结果来看就可以了。</li>
<li><code>foreach</code>是循环语句的一种，用来遍历一个数组的元素，这里则是遍历<code>netstat</code>命令每一行的内容。注意，<code>foreach</code>可以直接用<code>for</code>代替，即<code>for my $line (@netstat) { ... }</code>。</li>
<li><code>last</code>表示退出循环。如果要进入下一次循环，可使用<code>next</code>语句。</li>
</ul>


<h2>数组</h2>

<p>下面我们要根据进程号来获取JVM的GC信息：（“2017”为上文获取到的进程号）</p>

<p><code>bash
$ jstat -gc 2017
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   
192.0  192.0   0.0    50.1   1792.0   682.8     4480.0     556.3    21248.0 9483.2      3    0.008   0      0.000    0.008
</code></p>

<p>如何将以上输出结果转换为以下形式？</p>

<p><code>
s0c 192.0
s1c 192.0
...
</code></p>

<p>这时我们就需要更多地使用数组这一数据结构：</p>

<p><code>``perl
my $pid = 2017;
my @jstat =</code>jstat -gc $pid`;</p>

<p>$jstat[0] =~ s/<sup>\s+|\s+$//;</sup>
$jstat[1] =~ s/<sup>\s+|\s+$//;</sup></p>

<p>my @kv_keys = split(/\s+/, $jstat[0]);
my @kv_vals = split(/\s+/, $jstat[1]);</p>

<p>my $result = '';
for my $i (0 .. $#kv_keys) {</p>

<pre><code>$result .= "$kv_keys[$i] $kv_vals[$i]\n";
</code></pre>

<p>}</p>

<p>print $result;
```</p>

<ul>
<li>使用<code>$jstat[0]</code>获取数组的第一个元素，数组的下标从0开始，注意这里的<code>$</code>符号，而非<code>@</code>。</li>
<li><code>$#kv_keys</code>返回的是数组最大的下标，而非数组的长度。</li>
<li><code>for my $i (0 .. 10) {}</code>则是另一种循环结果，<code>$i</code>的值从0到10（含0和10）。</li>
</ul>


<p>对于正则表达式，这里也出现了两个新的用法：</p>

<ul>
<li><code>s/A/B/</code>表示将A的值替换为B，上述代码中是将首尾的空格去除；</li>
<li><code>split(A, B)</code>函数表示将字符串B按照正则A进行分割，并返回一个数组。</li>
</ul>


<p>另外在学习过程中还发现了这样一种写法：</p>

<p>```perl
my @jstat;</p>

<p>$jstat[0] =~ s/<sup>\s+|\s+$//;</sup>
$jstat[1] =~ s/<sup>\s+|\s+$//;</sup></p>

<p>map { s/<sup>\s+|\s+$//</sup> } @jstat;
```</p>

<p><code>map</code>函数会对数组中的每个元素应用第一个参数指向的函数（这里是一个匿名函数），当需要处理的数组元素很多时，这种是首选做法。具体内容读者可以自己去了解。</p>

<h2>函数</h2>

<p>我们可以用以下命令来获取指定进程的CPU和内存使用率：</p>

<p><code>bash
$ ps -o pcpu,rss -p 2017
%CPU   RSS
 0.1 21632
</code></p>

<p>格式和<code>jstat</code>是一样的，为了不再写一遍上文中的代码，我们可以将其封装为函数。</p>

<p>```perl
sub kv_parse {</p>

<pre><code>my @kv_data = @_;

map { s/^\s+|\s+$// } @kv_data;

my @kv_keys = split(/\s+/, $kv_data[0]);
my @kv_vals = split(/\s+/, $kv_data[1]);

my $result = '';
for my $i (0 .. $#kv_keys) {
    $result .= "$kv_keys[$i] $kv_vals[$i]\n";
}

return $result;
</code></pre>

<p>}</p>

<p>my $pid = 2017;
my @jstat = <code>jstat -gc $pid</code>;
my @ps = <code>ps -o pcpu,rss -p $pid</code>;</p>

<p>print kv_parse(@jstat);
print kv_parse(@ps);
```</p>

<p><code>sub</code>表示定义一个函数（subroutine），和其他语言不同的是，它没有参数列表，获取参数使用的是魔术变量<code>@_</code>：</p>

<p>```perl
sub hello {</p>

<pre><code>my $name1 = $_[0];
$name1 = shift @_;
my $name2 = shift(@_);
my $name3 = shift;
</code></pre>

<p>}</p>

<p>hello('111', '222', '333');
hello '111', '222', '333';
&amp;hello('111', '222', '333');
```</p>

<ul>
<li><code>$_[0]</code>和<code>shift @_</code>返回的都是第一参数。不同的是，<code>shift</code>函数会将这个参数从<code>@_</code>数组中移除；</li>
<li><code>shift @_</code>和<code>shift(@_)</code>是等价的，因为调用函数时参数列表可以不加括号；</li>
<li><code>shift @_</code>和只写<code>shift</code>也是等价的，该函数若不指定参数，则默认使用<code>@_</code>数组。</li>
<li><code>&amp;</code>符号也是比较特别的，主要作用有两个：一是告诉Perl解释器<code>hello</code>将是一个用户定义的函数，这样就不会和Perl原生关键字冲突；二是忽略函数原型（prototype）。具体可以参考这篇文章：<a href="https://www.socialtext.net/perl5/subroutines_called_with_the_ampersand">Subroutines Called With The Ampersand</a>。</li>
</ul>


<p>当传递一个数组给函数时，该数组不会被作为<code>@_</code>的第一个元素，而是作为<code>@_</code>本身。这也是很特别的地方。当传递多个数组，Perl会将这些数组进行拼接：</p>

<p>```perl
sub hello {</p>

<pre><code>for my $i (@_) {
    print $i;
}
</code></pre>

<p>}</p>

<p>my @arr1 = (1, 2); # 使用圆括号定义一个数组，元素以逗号分隔。
my @arr2 = (3, 4);</p>

<p>hello @arr1, @arr2; # 输出 1234
```</p>

<h2>小结</h2>

<p>对于初学者来讲，本文的信息量可能有些大了。但如果你已经有一定的编程经验（包括Bash），应该可以理解这些内容。</p>

<p>Perl文化的特色是“不只一种做法来完成一件事情”，所以我们可以看到很多不同的写法。但也有一些是大家普遍接受的写法，所以也算是一种规范吧。</p>

<p>下一章我们会继续完成这个监控脚本。</p>

<p>PS：本文的示例代码可以从<a href="https://github.com/jizhang/perl-jvm-monitoring-example">Github</a>中下载。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure实战(4)：编写Hadoop MapReduce脚本]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2013/02/09/cia-hadoop/"/>
    <updated>2013-02-09T16:43:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2013/02/09/cia-hadoop</id>
    <content type="html"><![CDATA[<h2>Hadoop简介</h2>

<p>众所周知，我们已经进入了大数据时代，每天都有PB级的数据需要处理、分析，从中提取出有用的信息。Hadoop就是这一时代背景下的产物。它是Apache基金会下的开源项目，受<a href="http://en.wikipedia.org/wiki/Apache_Hadoop#Papers">Google两篇论文</a>的启发，采用分布式的文件系统HDFS，以及通用的MapReduce解决方案，能够在数千台物理节点上进行分布式并行计算。</p>

<p>对于Hadoop的介绍这里不再赘述，读者可以<a href="http://hadoop.apache.org/">访问其官网</a>，或阅读<a href="http://product.dangdang.com/main/product.aspx?product_id=21127813">Hadoop权威指南</a>。</p>

<p>Hadoop项目是由Java语言编写的，运行在JVM之上，因此我们可以直接使用Clojure来编写MapReduce脚本，这也是本文的主题。Hadoop集群的搭建不在本文讨论范围内，而且运行MapReduce脚本也无需搭建测试环境。</p>

<!-- more -->


<h2>clojure-hadoop类库</h2>

<p>Hadoop提供的API是面向Java语言的，如果不想在Clojure中过多地操作Java对象，那就需要对API进行包装（wrapper），好在已经有人为我们写好了，它就是<a href="https://github.com/alexott/clojure-hadoop">clojure-hadoop</a>。</p>

<p>从clojure-hadoop的项目介绍中可以看到，它提供了不同级别的包装，你可以选择完全规避对Hadoop类型和对象的操作，使用纯Clojure语言来编写脚本；也可以部分使用Hadoop对象，以提升性能（因为省去了类型转换过程）。这里我们选择前一种，即完全使用Clojure语言。</p>

<h2>示例1：Wordcount</h2>

<p>Wordcount，统计文本文件中每个单词出现的数量，可以说是数据处理领域的“Hello, world!”。这一节我们就通过它来学习如何编写MapReduce脚本。</p>

<h3>Leiningen 2</h3>

<p>前几章我们使用的项目管理工具<code>lein</code>是1.7版的，而前不久Leiningen 2已经正式发布了，因此从本章开始我们的示例都会基于新版本。新版<code>lein</code>的安装过程也很简单：</p>

<p><code>bash
$ cd ~/bin
$ wget https://raw.github.com/technomancy/leiningen/stable/bin/lein
$ chmod 755 lein
$ lein repl
user=&gt;
</code></p>

<p>其中，<code>lein repl</code>这一步会下载<code>lein</code>运行时需要的文件，包括Clojure 1.4。</p>

<h3>新建项目</h3>

<p><code>bash
$ lein new cia-hadoop
</code></p>

<p>编辑<code>project.clj</code>文件，添加依赖项<code>clojure-hadoop "1.4.1"</code>，尔后执行<code>lein deps</code>。</p>

<h3>Map和Reduce</h3>

<p>MapReduce，简称mapred，是Hadoop的核心概念之一。可以将其理解为处理问题的一种方式，即将大问题拆分成多个小问题来分析和解决，最终合并成一个结果。其中拆分的过程就是Map，合并的过程就是Reduce。</p>

<p>以Wordcount为例，将一段文字划分成一个个单词的过程就是Map。这个过程是可以并行执行的，即将文章拆分成多个段落，每个段落分别在不同的节点上执行划分单词的操作。这个过程结束后，我们便可以统计各个单词出现的次数，这也就是Reduce的过程。同样，Reduce也是可以并发执行的。整个过程如下图所示：</p>

<p><img src="/medias/20130209/cia-hadoop-wordcount.png" alt="Wordcount" /></p>

<p>中间Shuffle部分的功能是将Map输出的数据按键排序，交由Reduce处理。整个过程全部由Hadoop把控，开发者只需编写<code>Map</code>和<code>Reduce</code>函数，这也是Hadoop强大之处。</p>

<h4>编写Map函数</h4>

<p>在本示例中，我们处理的原始数据是文本文件，Hadoop会逐行读取并调用Map函数。Map函数会接收到两个参数：<code>key</code>是一个长整型，表示该行在整个文件中的偏移量，很少使用；<code>value</code>则是该行的内容。以下是将一行文字拆分成单词的Map函数：</p>

<p>```clojure
;; src/cia_hadoop/wordcount.clj</p>

<p>(ns cia-hadoop.wordcount
  (:require [clojure-hadoop.wrap :as wrap]</p>

<pre><code>        [clojure-hadoop.defjob :as defjob])
</code></pre>

<p>  (:import [java.util StringTokenizer])
  (:use clojure-hadoop.job))</p>

<p>(defn my-map [key value]
  (map (fn [token] [token 1])</p>

<pre><code>   (enumeration-seq (StringTokenizer. value))))
</code></pre>

<p>```</p>

<p>可以看到，这是一个纯粹的Clojure函数，并没有调用Hadoop的API。函数体虽然只有两行，但还是包含了很多知识点的：</p>

<p><code>(map f coll)</code>函数的作用是将函数<code>f</code>应用到序列<code>coll</code>的每个元素上，并返回一个新的序列。如<code>(map inc [1 2 3])</code>会对每个元素做加1操作（参考<code>(doc inc)</code>），返回<code>[2 3 4]</code>。值得一提的是，<code>map</code>函数返回的是一个惰性序列（lazy sequence），即序列元素不会一次性完全生成，而是在遍历过程中逐个生成，这在处理元素较多的序列时很有优势。</p>

<p><code>map</code>函数接收的参数自然不会只限于Clojure内部函数，我们可以将自己定义的函数传递给它：</p>

<p>```clojure
(defn my-inc [x]
  (+ x 1))</p>

<p>(map my-inc [1 2 3]) ; -> [2 3 4]
```</p>

<p>我们更可以传递一个匿名函数给<code>map</code>。上一章提过，定义匿名函数的方式是使用<code>fn</code>，另外还可使用<code>#(...)</code>简写：</p>

<p><code>clojure
(map (fn [x] (+ x 1)) [1 2 3])
(map #(+ % 1) [1 2 3])
</code></p>

<p>对于含有多个参数的情况：</p>

<p><code>clojure
((fn [x y] (+ x y)) 1 2) ; -&gt; 3
(#(+ %1 %2) 1 2) ; -&gt; 3
</code></p>

<p><code>my-map</code>中的<code>(fn [token] [token 1])</code>即表示接收参数<code>token</code>，返回一个向量<code>[token 1]</code>，其作用等价于<code>#(vector % 1)</code>。为何是<code>[token 1]</code>，是因为Hadoop的数据传输都是以键值对的形式进行的，如<code>["apple" 1]</code>即表示“apple”这个单词出现一次。</p>

<p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html">StringTokenizer</a>则是用来将一行文字按空格拆分成单词的。他的返回值是<code>Enumeration</code>类型，Clojure提供了<code>enumeration-seq</code>函数，可以将其转换成序列进行操作。</p>

<p>所以最终<code>my-map</code>函数的作用就是：将一行文字按空格拆分成单词，返回一个形如<code>[["apple" 1] ["orange" 1] ...]</code>的序列。</p>

<h4>编写Reduce函数</h4>

<p>从上文的图表中可以看到，Map函数处理完成后，Hadoop会对结果按照键进行排序，并使用<code>key, [value1 value2 ...]</code>的形式调用Reduce函数。在clojure-hadoop中，Reduce函数的第二个参数是一个函数，其返回结果才是值的序列：</p>

<p><code>clojure
(defn my-reduce [key values-fn]
  [[key (reduce + (values-fn))]])
</code></p>

<p>和Map函数相同，Reduce函数的返回值也是一个序列，其元素是一个个<code>[key value]</code>。注意，函数体中的<code>(reduce f coll)</code>是Clojure的内置函数，其作用是：取<code>coll</code>序列的第1、2个元素作为参数执行函数<code>f</code>，将结果和<code>coll</code>序列的第3个元素作为参数执行函数<code>f</code>，依次类推。因此<code>(reduce + [1 2 3])</code>等价于<code>(+ (+ 1 2) 3)</code>。</p>

<h4>定义脚本</h4>

<p>有了Map和Reduce函数，我们就可以定义一个完整的脚本了：</p>

<p><code>clojure
(defjob/defjob job
  :map my-map
  :map-reader wrap/int-string-map-reader
  :reduce my-reduce
  :input-format :text
  :output-format :text
  :compress-output false
  :replace true
  :input "README.md"
  :output "out-wordcount")
</code></p>

<p>简单说明一下这些配置参数：<code>:map</code>和<code>:reduce</code>分别指定Map和Reduce函数；<code>map-reader</code>表示读取数据文件时采用键为<code>int</code>、值为<code>string</code>的形式；<code>:input-format</code>至<code>compress-output</code>指定了输入输出的文件格式，这里采用非压缩的文本形式，方便阅览；<code>:replace</code>表示每次执行时覆盖上一次的结果；<code>:input</code>和<code>:output</code>则是输入的文件和输出的目录。</p>

<h4>执行脚本</h4>

<p>我们可以采用Clojure的测试功能来执行脚本：</p>

<p>```clojure
;; test/cia_hadoop/wordcount_test.clj</p>

<p>(ns cia-hadoop.wordcount-test
  (:use clojure.test</p>

<pre><code>    clojure-hadoop.job
    cia-hadoop.wordcount))
</code></pre>

<p>(deftest test-wordcount
  (is (run job)))
```</p>

<p>尔后执行：</p>

<p><code>bash
$ lein test cia-hadoop.wordcount-test
...
13/02/14 00:25:52 INFO mapred.JobClient:  map 0% reduce 0%
..
13/02/14 00:25:58 INFO mapred.JobClient:  map 100% reduce 100%
...
$ cat out-wordcount/part-r-00000
...
"java"  1
"lein"  3
"locally"   2
"on"    1
...
</code></p>

<p>如果想要将MapReduce脚本放到Hadoop集群中执行，可以采用以下命令：</p>

<p><code>bash
$ lein uberjar
$ hadoop jar target/cia-hadoop-0.1.0-SNAPSHOT-standalone.jar clojure_hadoop.job -job cia-hadoop.wordcount/job
</code></p>

<h2>示例2：统计浏览器类型</h2>

<p>下面我们再来看一个更为实际的示例：从用户的访问日志中统计浏览器类型。</p>

<h3>需求概述</h3>

<p>用户访问网站时，页面中会有段JS请求，将用户的IP、User-Agent等信息发送回服务器，并记录成文本文件的形式：</p>

<p><code>text
{"stamp": "1346376858286", "ip": "58.22.113.189", "agent": "Mozilla/5.0 (iPad; CPU OS 5_0_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A405 Safari/7534.48.3"}
{"stamp": "1346376858354", "ip": "116.233.51.2", "agent": "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)"}
{"stamp": "1346376858365", "ip": "222.143.28.2", "agent": "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)"}
{"stamp": "1346376858423", "ip": "123.151.144.40", "agent": "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11"}
</code></p>

<p>我们要做的是从User-Agent中统计用户使用的浏览器类型所占比例，包括IE、Firefox、Chrome、Opera、Safari、以及其它。</p>

<h3>User-Agent中的浏览器类型</h3>

<p>由于一些<a href="http://webaim.org/blog/user-agent-string-history/">历史原因</a>，User-Agent中的信息是比较凌乱的，浏览器厂商会随意添加信息，甚至仿造其它浏览器的内容。因此在过滤时，我们需要做些额外的处理。Mozilla的<a href="https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent">这篇文章</a>很好地概括了如何从User-Agent中获取浏览器类型，大致如下：</p>

<ul>
<li>IE: MSIE xyz</li>
<li>Firefox: Firefox/xyz</li>
<li>Chrome: Chrome/xyz</li>
<li>Opera: Opera/xyz</li>
<li>Safari: Safari/xyz, 且不包含 Chrome/xyz 和 Chromium/xyz</li>
</ul>


<h3>解析JSON字符串</h3>

<p>Clojure除了内置函数之外，周边还有一个名为<code>clojure.contrib</code>的类库，其中囊括了各类常用功能，包括JSON处理。目前<code>clojure.contrib</code>中的各个组件已经分开发行，读者可以到 https://github.com/clojure 中浏览。</p>

<p>处理JSON字符串时，首先在项目声明文件中添加依赖项<code>[org.clojure/data.json "0.2.1"]</code>，然后就能使用了：</p>

<p><code>clojure
user=&gt; (require '[clojure.data.json :as json])
user=&gt; (json/read-str "{\"a\":1,\"b\":2}")
{"a" 1, "b" 2}
user=&gt; (json/write-str [1 2 3])
"[1,2,3]"
</code></p>

<h3>正则表达式</h3>

<p>Clojure提供了一系列的内置函数来使用正则表达式，其实质上是对<code>java.util.regex</code>命名空间的包装。</p>

<p><code>clojure
user=&gt; (def ptrn #"[0-9]+") ; #"..."是定义正则表达式对象的简写形式
user=&gt; (def ptrn (re-pattern "[0-9]+")) ; 和上式等价
user=&gt; (re-matches ptrn "123") ; 完全匹配
"123"
user=&gt; (re-find ptrn "a123") ; 返回第一个匹配项
"123"
user=&gt; (re-seq ptrn "a123b456") ; 返回匹配项序列（惰性序列）
("123" "456")
user=&gt; (re-find #"([a-z]+)/([0-9]+)" "a/1") ; 子模式
["a/1" "a" "1"]
user=&gt; (def m (re-matcher #"([a-z]+)/([0-9]+)" "a/1 b/2")) ; 返回一个Matcher对象
user=&gt; (re-find m) ; 返回第一个匹配
["a/1" "a" "1"]
user=&gt; (re-groups m) ; 获取当前匹配
["a/1" "a" "1"]
user=&gt; (re-find m) ; 返回下一个匹配，或nil
["b/2" "b" "2"]
</code></p>

<h3>Map函数</h3>

<p>```clojure
(defn json-decode [s]
  (try</p>

<pre><code>(json/read-str s)
(catch Exception e)))
</code></pre>

<p>(def rule-set {"ie" (partial re-find #"(?i)MSIE [0-9]+")</p>

<pre><code>           "chrome" (partial re-find #"(?i)Chrome/[0-9]+")
           "firefox" (partial re-find #"(?i)Firefox/[0-9]+")
           "opera" (partial re-find #"(?i)Opera/[0-9]+")
           "safari" #(and (re-find #"(?i)Safari/[0-9]+" %)
                          (not (re-find #"(?i)Chrom(e|ium)/[0-9]+" %)))
           })
</code></pre>

<p>(defn get-type [ua]
  (if-let [rule (first (filter #((second %) ua) rule-set))]</p>

<pre><code>(first rule)
"other"))
</code></pre>

<p>(defn my-map [key value]
  (when-let [ua (get (json-decode value) "agent")]</p>

<pre><code>[[(get-type ua) 1]]))
</code></pre>

<p>```</p>

<p><code>json-decode</code>函数是对<code>json/read-str</code>的包装，当JSON字符串无法正确解析时返回<code>nil</code>，而非异常终止。</p>

<p><code>rule-set</code>是一个<code>map</code>类型，键是浏览器名称，值是一个函数，这里都是匿名函数。<code>partial</code>用于构造新的函数，<code>(partial + 1)</code>和<code>#(+ 1 %)</code>、<code>(fn [x] (+ 1 x))</code>是等价的，可以将其看做是为函数<code>+</code>的第一个参数定义了默认值。正则表达式中的<code>(?i)</code>表示匹配时不区分大小写。</p>

<p><code>get-type</code>函数中，<code>(filter #((second %) ua) rule-set)</code>会用<code>rule-set</code>中的正则表达式逐一去和User-Agent字符串进行匹配，并返回第一个匹配项，也就是浏览器类型；没有匹配到的则返回<code>other</code>。</p>

<h3>单元测试</h3>

<p>我们可以编写一组单元测试来检验上述<code>my-map</code>函数是否正确：</p>

<p>```clojure
;; test/cia_hadoop/browser_test.clj</p>

<p>(ns cia-hadoop.browser-test
  (:use clojure.test</p>

<pre><code>    clojure-hadoop.job
    cia-hadoop.browser))
</code></pre>

<p>(deftest test-my-map
  (is (= [["ie" 1]] (my-map 0 "{\"agent\":\"MSIE 6.0\"}")))
  (is (= [["chrome" 1]] (my-map 0 "{\"agent\":\"Chrome/20.0 Safari/6533.2\"}")))
  (is (= [["other" 1]] (my-map 0 "{\"agent\":\"abc\"}")))
  (is (nil? (my-map 0 "{"))))</p>

<p>(deftest test-browser
  (is (run job)))
```</p>

<p>其中<code>deftest</code>和<code>is</code>都是<code>clojure.test</code>命名空间下定义的。</p>

<p><code>bash
$ lein test cia-hadoop.browser-test
</code></p>

<h2>小结</h2>

<p>本章我们简单介绍了Hadoop这一用于大数据处理的开源项目，以及如何借助clojure-hadoop类库编写MapReduce脚本，并在本地和集群上运行。Hadoop已经将大数据处理背后的种种细节都包装了起来，用户只需编写Map和Reduce函数，而借助Clojure语言，这一步也变的更为轻松和高效。Apache Hadoop是一个生态圈，其周边有很多开源项目，像Hive、HBase等，这里再推荐一个使用Clojure语言在Hadoop上执行查询的工具：<a href="https://github.com/nathanmarz/cascalog">cascalog</a>。它的作者是<a href="http://nathanmarz.com/">Nathan Marz</a>，也是我们下一章的主题——Storm实时计算框架——的作者。</p>

<p>本文涉及到的源码可以到 https://github.com/jizhang/cia-hadoop 中查看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure实战(3)：使用Noir框架开发博客(下)]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2012/12/16/cia-noir-3/"/>
    <updated>2012-12-16T20:20:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2012/12/16/cia-noir-3</id>
    <content type="html"><![CDATA[<h2>Session和Cookie</h2>

<p>做网络编程的人肯定对这两个概念不陌生，因此这里就不介绍它们的定义和作用了。我们要实现的需求也很简单：用户通过一个表单登录，在当前窗口中保持登录状态，并可以选择“记住我”来免去关闭并新开窗口之后的重登录。显然，前者使用Session，后者使用Cookie。下面我们就来看Noir对这两者的支持。</p>

<h3>Session</h3>

<p><code>clojure
(require 'noir.session)
(noir.session/put! :username "john")
(noir.session/get :username "nobody")
(noir.session/clear!)
</code></p>

<p>很简单的API。注意<code>put!</code>函数中的<code>!</code>，和之前遇到的<code>?</code>一样，这种特殊字符是合法的函数名，但<code>!</code>习惯用来表示该方法会改变某个对象的状态，这里<code>put!</code>就表示会改变Session的状态。</p>

<p>Noir还提供了一种“闪信（Flash）”机制，主要用于在页面跳转之间暂存消息。如用户登录后会跳转到首页，如果想在首页显示“登录成功”的信息，就需要用到闪信了。闪信的API也放置在<code>noir.session</code>命名空间下：</p>

<p><code>clojure
(noir.session/flash-put! "登录成功")
(noir.session/flash-get)
</code></p>

<p>闪信的生命周期是一次请求，即在设置了闪信后的下一个请求中，可以多次<code>flash-get</code>，但再下一次请求就获取不到值了。</p>

<!-- more -->


<h3>Cookie</h3>

<p>Cookie的API示例如下：</p>

<p><code>clojure
(require 'noir.cookies)
(noir.cookies/put! :user_id (str 1))
(noir.cookies/get :user_id)
(noir.cookies/put! :tracker {:value (str 29649) :path "/" :max-age 3600})
</code></p>

<p>需要注意的是，<code>put!</code>函数只支持字符串类型；对于Cookie超时时间的设置，一种是上面所写的多少秒过期，另一种是传入一个DateTime对象。对于时间日期的处理，Java自带的类库可能不太好用，这里推荐<a href="http://joda-time.sourceforge.net/">Joda Time</a>，它有更丰富的功能和更友善的API。</p>

<h2>登录页面</h2>

<p>这里我们跳过注册页面，因为它实现的功能和新建一篇文章很相近，所以读者可以自己完成。我们假定用户信息表的格式如下：</p>

<p><code>sql
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) NOT NULL,
  `password` varchar(32) NOT NULL,
  PRIMARY KEY (`id`)
)
</code></p>

<p>其中password字段保存的是密码的MD5值（32位16进制字符串）。Clojure中没有提供专门的类库，因此需要调用Java来实现。下文会贴出它的实现代码。</p>

<p>我们重点来看对登录页面表单的处理。新建<code>src/blog/views/login.clj</code>文件，添加对<code>/login</code>的路由，显示一个包含用户名、密码、以及“记住我”复选框的表单。用户提交后，若验证成功，会跳转至<code>/whoami</code>页面，用来显示保存在session或者cookie中的信息。以下是关键代码：</p>

<p>```clojure
(defpage [:post "/login"] {:as forms}
  (let [userid (model-user/get-id (:username forms) (:password forms))]</p>

<pre><code>(if userid
  (do (session/put! :userid userid)
      (session/put! :username (:username forms))
      (when (= (:remember-me forms) "1") ; “记住我”复选框
        (cookies/put! :userid {:value (str userid) :max-age 86400}) ; 保存登录状态，时限1天。
        (cookies/put! :username {:value (:username forms) :max-age 86400}))
      (response/redirect "/whoami")) ; noir.response/redirect 302跳转
  (render "/login" forms))))
</code></pre>

<p>(defpage "/whoami" [] ; 先检测Session，再检测Cookie。
  (if-let [userid (session/get :userid)]</p>

<pre><code>(session/get :username)
(if-let [userid (cookies/get :userid)]
  (do
    (session/put! :userid userid)
    (let [username (cookies/get :username)]
      (session/put! :username username)
      username))
  "unknown")))
</code></pre>

<p>```</p>

<p>其中<code>if-let</code>和以下代码是等价的，类似的有<code>when-let</code>。</p>

<p>```clojure
(let [userid (session/get :userid)]
  (if userid</p>

<pre><code>(do ...)
"unkown"))
</code></pre>

<p>```</p>

<p>对用户表的操作我们放到<code>src/blog/models/user.clj</code>文件中：</p>

<p>```clojure
(ns blog.models.user
  (:require [clojure.java.jdbc :as sql]</p>

<pre><code>        [blog.util :as util])
</code></pre>

<p>  (:use [blog.database :only [db-spec]]))</p>

<p>(defn get-id [username password]
  (let [password-md5 (util/md5 password)]</p>

<pre><code>(sql/with-connection db-spec
  (sql/with-query-results rows
    ["SELECT `id` FROM `user` WHERE `username` = ? AND `password` = ?"
     username password-md5] ; 不要采用直接拼接字符串的方式，有SQL注入的危险。
    (:id (first rows))))))
</code></pre>

<p>```</p>

<p>最后，我们将MD5加密这类的函数放到<code>src/blog/util.clj</code>文件中：</p>

<p>```clojure
(ns blog.util
  (:import java.security.MessageDigest</p>

<pre><code>       java.math.BigInteger))
</code></pre>

<p>(defn md5 [s]
  (let [algorithm (MessageDigest/getInstance "MD5")</p>

<pre><code>    size (* 2 (.getDigestLength algorithm))
    raw (.digest algorithm (.getBytes s))
    sig (.toString (BigInteger. 1 raw) 16)
    padding (apply str (repeat (- size (count sig)) "0"))]
(str padding sig)))
</code></pre>

<p>```</p>

<p><code>padding</code>的作用是当计算得到的MD5字符串不足32位时做补零的操作。如何得到一个包含N个"0"的字符串？这就是<code>(apply...)</code>那串代码做的工作。简单来说，<code>repeat</code>函数会返回一个序列，<code>apply</code>函数首先使用第1、第2个元素作为参数调用<code>str</code>函数，然后将执行结果和第3个元素作为参数调用<code>str</code>，依此类推。因此，<code>(apply str [1 2 3])</code>等价于<code>(str (str 1 2) 3)</code>。<code>clojure.string/join</code>提供了将序列连接为字符串的功能，用法是<code>(clojure.string/join (repeat ...))</code>，查看它的源码<code>(source clojure.string/join)</code>可以发现，它实质上也是采用了<code>apply</code>函数。</p>

<p>序列是Clojure的一个很重要的数据结构，有多种函数和惯用法，需要逐步积累这些知识。</p>

<h2>中间件</h2>

<p>如果需要在程序的多个地方获取用户的登录状态，可以将上述<code>/whoami</code>中的方法封装成函数，但是每次都要执行一次似乎有些冗余，因此我们可以将它放到中间件（Middleware）中。</p>

<p>中间件是<a href="http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">WSGI</a>类的网站程序中很重要的特性。如果将用户的一次访问分解成<code>请求-&gt;处理1-&gt;处理2-&gt;应答</code>，那么中间件就是其中的“处理”部分，可以增加任意多个。Noir的很多功能，像路由、Session等，都是通过中间件的形式进行组织的。</p>

<p>以下是一个空的中间件代码：</p>

<p>```clojure
(ns ...</p>

<pre><code>(:require [noir.server :as server]))
</code></pre>

<p>(defn my-middleware [handler]
  (fn [request]</p>

<pre><code>(handler request)))
</code></pre>

<p>(erver/add-middleware my-middleware)
```</p>

<p>上述代码添加到<code>src/blog/server.clj</code>中可以直接运行，只是这个中间件没有做任何工作。中间件是一个函数，返回值是一个匿名函数（<code>defn</code>是基于<code>fn</code>的，详情可见<code>(doc defn)</code>）。<code>handler</code>参数则是前一个中间件返回的匿名函数，<code>request</code>是用户发送过来的请求（map形式）。这些中间件组合起来就成为了一条处理链。<code>add-middleware</code>则是Noir定义的函数，将用户自定义的中间件添加到处理链中。</p>

<p>下面我们就写这样一个中间件，每次请求时都去检测Session和Cookie中是否包含用户的登录信息，并将该信息放到<code>request</code>的map中：</p>

<p>```clojure
(defn authenticate [handler]
  (fn [request]</p>

<pre><code>(let [user (if-let [userid (session/get :userid)]
            [userid (session/get :username)]
            (when-let [userid (cookies/get :userid)]
              (let [username (cookies/get :username)]
                (do
                  (session/put! :userid userid)
                  (session/put! :username username)
                  [userid username]))))
      req (if user
            (assoc request :user (zipmap [:userid :username] user))
            request)]
  (handler req))))
</code></pre>

<p>```</p>

<p>这段代码中对于session和cookies的调用和上面没有差异，比较陌生的可能是<code>assoc</code>和<code>zipmap</code>方法，他们都是用来操作map数据类型的：前者会向一个map对象添加键值，并返回一个新的map；后者则会接收两个序列作为参数，两两组合成一个map并返回。</p>

<p>这样我们就能将<code>/whoami</code>的代码修改为：</p>

<p>```clojure
(ns ...</p>

<pre><code>(:require [noir.request :as request]))
</code></pre>

<p>(defpage "/whoami" []</p>

<pre><code>     (if-let [user (:user (request/ring-request))]
       (:username user)
       "unkown"))
</code></pre>

<p>```</p>

<p>其中，<code>ring-request</code>用来获得用户的<code>request</code>map对象。</p>

<h2>程序发布</h2>

<p>这里介绍三种Web应用程序的发布方式。</p>

<h3>直接使用Leiningen</h3>

<p>如果服务器上安装有<code>lein</code>环境，则可以直接调用它来启动程序。只有一点需要注意，因为在默认情况下，<code>lein run</code>启动的程序会被包装在Leiningen的JVM中，这样会占用一些额外的内存，同时引起一些<code>stdin</code>方面的问题。解决方法是使用<code>lein trampoline run</code>命令来启动程序，这样Leiningen为程序启动一个独立的JVM，并退出自己的JVM。</p>

<h3>编译为独立Jar包</h3>

<p><code>lein uberjar</code>命令可以将项目编译后的代码及其所有的依赖包打入一个Jar文件中，和Maven的assembly插件类似。需要注意的是，Clojure文件在默认情况下是不会生成类文件的，而是在运行时进行解析。这样一来，当使用<code>java -jar</code>命令执行时会提示找不到类定义的错误。解决方法是为包含入口函数的模块生成类文件，需要在<code>src/blog/server.clj</code>的<code>ns</code>声明中添加<code>gen-class</code>标识：</p>

<p>```clojure
(ns blog.server</p>

<pre><code>...
(:gen-class))
</code></pre>

<p>```</p>

<p>然后就能打包运行了：</p>

<p><code>bash
$ lein uberjar
$ java -jar blog-0.1.0-SNAPSHOT-standalone.jar
2012-12-23 00:07:47.417:INFO::jetty-6.1.x
2012-12-23 00:07:47.430:INFO::Started SocketConnector@0.0.0.0:8080
</code></p>

<p>可以在程序前部署一个Nginx代理做转发，配置方法就不在这里赘述了。</p>

<h3>使用Tomcat</h3>

<p>以上两种方法使用的都是Jetty这个Web容器，虽然比较方便，但在生产环境中我们更倾向于使用Tomcat。</p>

<p>对于Tomcat的安装这里不做讲解，读者可以到<a href="http://tomcat.apache.org/">Tomcat官网</a>查阅。</p>

<p>Clojure代码也需要做一些修改，我们需要提供一个接口供Tomcat调用，也就是<code>Handler</code>。在<code>src/blog/server.clj</code>中添加以下代码：</p>

<p>```clojure
(def handler (server/gen-handler</p>

<pre><code>           {:mode :prod,
            :ns 'blog}))
</code></pre>

<p>```</p>

<p><code>gen-handler</code>是Noir的函数，用来生成一个<code>Handler</code>。<code>'blog</code>前的单引号大家应该还有印象，它表示命名空间。</p>

<p><code>server.clj</code>还有一项内容需要修改：删除<code>load-views</code>，改为显式的<code>require</code>，这样才能保证在编译期间就加载路由配置，Tomcat才会认可。代码如下：</p>

<p>```clojure
(ns ...</p>

<pre><code>(:require [blog.views welcome article]))
</code></pre>

<p>; (server/load-views "src/blog/views")
```</p>

<p>和<code>uberjar</code>类似，我们需要使用<code>uberwar</code>来打包成一个包含所有依赖项的war包。不过这个工具是由一个Leiningen插件提供的：<code>lein-ring</code>，安装过程和<code>lein-noir</code>类似，首先在<code>project.clj</code>添加dev依赖，然后执行<code>lein deps</code>安装。要使上述<code>handler</code>生效，<code>project.clj</code>中还需要增加一项名为<code>:ring</code>的配置：</p>

<p>```clojure
(defproject blog ...</p>

<pre><code>        ...
        :dev-dependencies [...
                           [lein-ring "0.7.5"]]
        :ring {:handler blog.server/handler})
</code></pre>

<p>```</p>

<p>执行<code>lein ring uberwar</code>命令，将生成的war包放置到Tomcat的webapps目录中，命名为ROOT.war，也可以设置<a href="http://tomcat.apache.org/tomcat-7.0-doc/virtual-hosting-howto.html">Virtual Hosting</a>。片刻后，Tomcat会应用这个新的程序，我们就能在浏览器中访问了。</p>

<h2>发布至云端Heroku</h2>

<p>最后，我们来尝试将这个博客程序部署到线上环境中。如今云计算已经非常流行，有许多优秀的<a href="http://en.wikipedia.org/wiki/Platform_as_a_service">PaaS</a>平台，<a href="http://www.heroku.com">Heroku</a>就是其中之一。在Heroku上部署一个小型的应用是完全免费的，这里我们简述一下步骤，更详细的操作方法可以参考它的<a href="https://devcenter.heroku.com/articles/clojure">帮助文档</a>。</p>

<ul>
<li>登录Heroku网站并注册账号；</li>
<li>安装<a href="https://toolbelt.heroku.com/">Tookbelt</a>，从而能在命令行中使用<code>heroku</code>命令；</li>
<li>执行<code>heroku login</code>命令，输入账号密码，完成验证；</li>
<li>新建<code>src/Procfile</code>文件，输入<code>web: lein trampoline run blog.server</code>；</li>
<li>执行<code>foreman start</code>命令，可以在本地测试程序；</li>
<li>执行<code>heroku create</code>，Heroku会为你分配一个空间；</li>
<li>执行<code>git push heroku master</code>，将本地代码推送至云端，可以看到编译信息，并得到一个URL，通过它就能访问我们的应用程序了。</li>
</ul>


<p>以上步骤省略了数据库的配置，读者可以自行到<a href="https://addons.heroku.com/cleardb">Heroku ClearDB</a>页面查看配置方法。</p>

<h2>小结</h2>

<p>至此我们完成了对Noir网站开发框架的简介，也完成了对Clojure这门语言的入门介绍。不过《Clojure实战》系列还远没有结束，下一章开始我们会进入Clojure语言更擅长的领域——计算。我们会陆续介绍如何使用Clojure编写<a href="http://hadoop.apache.org">Hadoop</a> MapReduce脚本、编写<a href="http://www.storm-project.net">Storm</a> Topology、以及如何使用<a href="http://incanter.org/">Incanter</a>进行可视化数据分析。不过在此之前，我强烈建议读者能够回头看看第一章中提到的几个Clojure教程，这样能对Clojure语言的整体架构有一个印象，接下来的学习才会更为顺畅。</p>

<h3>PS</h3>

<p>在撰写这份Noir框架教程时，Noir作者宣布停止对Noir的开发和维护，鼓励开发者转而使用Ring+Compojure+lib-noir的方式进行开发。这对我们并无太大影响，毕竟我们只是利用Noir来学习Clojure，而且前文提过Noir本身就是基于Ring和Compojure这两个类库的，迁移起来非常方便，我会为此再写一篇博客的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure实战(2)：使用Noir框架开发博客(中)]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2012/12/08/cia-noir-2/"/>
    <updated>2012-12-08T12:09:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2012/12/08/cia-noir-2</id>
    <content type="html"><![CDATA[<h2>在Eclipse中编写Clojure代码</h2>

<p>从这章起我们就要开始真正的编码了。Vim可能是很多程序员的选择，但如果你像我一样更喜欢GUI界面，那就来看看如何在Eclipse中编写Clojure代码吧。</p>

<h3>安装Eclipse插件</h3>

<p>Eclipse提供了一个Clojure插件：CounterClockwise，可以用来编写Clojure代码，进行语法高亮、调试等操作。打开Eclipse的Market Place，搜索counterclockwise关键字，点击Install即可。</p>

<h3>将Leiningen项目导入Eclipse</h3>

<p>由于CounterClockwise插件并没有默认使用Leiningen来管理项目，因此需要做一些额外的工作。</p>

<p>在使用<code>lein new</code>命令创建项目后，在project.clj文件中增加如下一行：</p>

<p>```clojure
(defproject ...</p>

<pre><code>        :dev-dependencies [[lein-eclipse "1.0.0"]]
        ...)
</code></pre>

<p>```</p>

<p>然后依次执行<code>lein deps</code>和<code>lein eclipse</code>，会看到项目根目录下生成了.project和.classpath文件。然后就可以进入Eclipse导入这个项目了。如果使用Git进行版本控制，<code>lein</code>已经为你生成好了.gitignore文件。执行了<code>git init</code>后，就能在Eclilpse中选择Share Project菜单项，进行可视化的版本控制。</p>

<h2>使用表单</h2>

<p>我们现在需要编写一个新建文章的功能，它是一个简单的页面，页面上有“标题”和“内容”两个文本框，并有一个“提交”按钮。</p>

<p>在src/blog/views目录下新建一个文件article.clj，输入以下内容：</p>

<p>```clojure
(ns blog.views.article
  (:require [blog.views.common :as common])
  (:use [noir.core]</p>

<pre><code>    [hiccup.form-helpers]))
</code></pre>

<p>(defpage "/blog/add" []
  (common/layout</p>

<pre><code>[:h1 "新建文章"]
(form-to [:post "/blog/add"]
         (label "title" "标题：")
         (text-field {:size 50} "title") [:br]
         (label "content" "内容：")
         (text-area {:rows 20 :cols 50} "content") [:br]
         (submit-button "提交"))))
</code></pre>

<p>```</p>

<p><code>defpage</code>和<code>common/layout</code>我们之前已经见到过，前者定义了URL<code>/blog/add</code>指向的页面，后者则是套用了一个模板。<code>[:h1 ...]</code>和<code>[:br]</code>也应该熟悉，它们是Hiccup的语法，分别生成<code>&lt;h1&gt;...&lt;/h1&gt;</code>和<code>&lt;br&gt;</code>标签。</p>

<!-- more -->


<p><code>form-to</code>是一个新的语法，不过从名字上也可以猜到，它用来生成一个<code>&lt;form&gt;</code>标签，结合<code>[:post "/blog/add"]</code>一起来看就是<code>&lt;form action="/blog/add" method="post"&gt;...&lt;/form&gt;</code>。至于<code>label</code>、<code>text-field</code>、<code>text-area</code>、以及<code>submit-button</code>都是用来生成相应的表单标签的，它们包含在hiccup.form-helpers命名空间中，具体用法可以到REPL中查看它们的文档，如：（在项目目录中执行<code>lein repl</code>）</p>

<p>```clojure
blog.server=> (use 'hiccup.form-helpers)
nil</p>

<h2>blog.server=> (doc label)</h2>

<p>hiccup.form-helpers/label
([name text]) ; 这个函数接受两个参数，第一个参数是for属性，第二个是它的文本，即<label for="name">text</label>。
  Creates a label for an input field with the supplied name.
nil</p>

<h2>blog.server=> (doc text-field)</h2>

<p>hiccup.form-helpers/text-field
([name] [name value]) ; 这个函数可以传一个或两个参数，第一个参数是name属性，第二个参数是value，即<input type="text" name="name" value="value">。
  Creates a new text input field.
nil
```</p>

<p><code>{:size 50}</code>是个很特别的地方，虽然从字面上就能猜出它是<code>&lt;input&gt;</code>标签的<code>size</code>属性，用来设置文本框的长度的，但为什么会是这样的语法呢？这是Clojure定义的吗？当然不是。还记得我们之前提过的宏吗？开发者可以用宏来定义新的语法，Hiccup就定义了这样的语法，可以用map的形式传入额外的HTML属性。尝试在REPL中执行<code>(html [:font {:color "red"} "hi"])</code>，看看结果是什么吧。</p>

<h3>接收表单信息</h3>

<p>接下来我们再创建一个页面来接收表单信息。Noir可以按照HTTP方式的不同（GET、POST、DELETE等）来进行路由，比如同样是<code>/blog/add</code>这个URL，我们可以为它创建一个独立的页面，响应POST请求：</p>

<p><code>clojure
(defpage [:post "/blog/add"] []
  "添加成功")
</code></p>

<p>尝试提交刚才的页面，会发现得到了预期结果：添加成功。那如何接收表单信息呢？</p>

<p><code>clojure
(defpage [:post "/blog/add"] {:as forms}
  (str "添加成功，文章标题是：" (:title forms)))
</code></p>

<p>似乎又多了几个新奇的语法，我们一一来解释：</p>

<p><code>{:as forms}</code>是一种解构（destructuring）语法，解构的对象是list或map，将它们包含的元素拆解出来。Noir在调用页面函数时（defpage实质上是创建了一个函数）会将接收到的参数以map的形式传递给该函数，如<code>title=greeting&amp;content=helloworld</code>会以`{:title "greeting", :content "helloworld"}的形式传递过来，函数可以通过以下几种方式对map类型进行解构：</p>

<ul>
<li>不接收参数，使用<code>[]</code>来表示。</li>
<li>接收指定名称的参数，如<code>{title :title, content :content}</code>，它会将map中键名为:title的值赋给title变量，:content的内容赋给content变量，其他的键名会丢弃。如果键名很多，可以用这种缩写形式：<code>{:keys [title content]}</code>。</li>
<li>接收整个map，使用<code>{:as forms}</code>，其中forms是自定义的，这样就能从forms变量中获取某个键的值。</li>
<li>将以上两者结合，即<code>{title :title, content :content, :as forms}</code>，需要注意的是forms中还是包含:title和:content的，不会因为它们已经被赋值给其他变量了而从map中剔除掉。</li>
</ul>


<p>你可以将上面这段代码中的<code>{:as forms}</code>替换成其他形式来进行实验，看看是否真的掌握了解构的用法。至于对list对象的解构，我们以后会遇到。</p>

<p>如何获取map中某个键的值？之前我们在与Java交互时提过有两种方法：<code>(get forms :title)</code>和<code>(.get forms :title)</code>，这里展示的是第三种：<code>(:title forms)</code>，即用关键字作为一个函数，获取map中的值。如果键不存在则返回nil，可以提供默认值：<code>(:title forms "Default Title")</code>。</p>

<p><code>str</code>则是一个函数，会将它所接收到的所有参数转换成字符串并拼接起来（中间不会添加空格）。</p>

<h3>表单验证</h3>

<p>“永远不要相信用户输入的信息”，我们必须对表单内容进行验证，比如标题为空时我们应该显示错误信息，并让用户重新填写。Noir提供了表单验证的相关函数，位于noir.validation命名空间下。下面我们就来添加简单的验证功能：</p>

<p>```clojure
(ns ...
  (:require [noir.validation :as vali]))</p>

<p>(defn valid? [{:keys [title content]}]
  (vali/rule (vali/has-value? title)</p>

<pre><code>         [:title "标题不能为空。"])
</code></pre>

<p>  (vali/rule (vali/min-length? title 10)</p>

<pre><code>         [:title "标题不能少于10个字符。"])
</code></pre>

<p>  (vali/rule (vali/has-value? content)</p>

<pre><code>         [:content "内容不能为空。"])
</code></pre>

<p>  (not (vali/errors? :title :content)))</p>

<p>(defpage [:post "/blog/add"] {:as forms}
  (if (valid? forms)</p>

<pre><code>(str "添加成功，文章标题是：" (:title forms))
(str (vali/get-errors :title) (vali/get-errors :content))))
</code></pre>

<p>```</p>

<p>这段代码的运行效果是：如果提交的表单中标题和内容都有值，则显示“添加成功”，否则提示“标题不为空”、“内容不为空”等。我们来分析一下这段代码。</p>

<p><code>defn</code>定义一个函数，它的参数使用了前面提到的解构，函数体则是由三条语句构成。<code>valid?</code>是合法的函数名吗？前面提过Clojure的变量可以包含特殊字符，所以函数名中是可以存在<code>?</code>、<code>!</code>等字符的。当然我们也有一些习惯，比如以<code>?</code>结尾的函数名一般会返回布尔型。</p>

<p><code>vali/rule</code>函数用来描述一个验证规则，它的第一个参数是一个能够返回布尔型的表达式，第二个参数是一个向量（vector），包含两个元素，分别是字段名和错误提示信息，用于生成一个包含所有错误信息的map。以上面这段代码为例，如果三条验证都不通过，那生成的错误信息会是<code>{:title ["标题不能为空。" "标题不能少于10个字符。"], :content ["内容不能为空。"]}</code>。不过，这个map是由<code>noir.validation</code>维护的，我们不能直接获取到。</p>

<p><code>vali/errors?</code>接收一个字段列表，如果有一个字段验证不通过（产生了错误信息）则返回真，<code>not</code>函数自然就是将这个“真”转换为“假”，从而和<code>valid?</code>的语义一致，即不合法（验证不通过）。</p>

<p>最后，<code>vali/get-errors</code>函数可以将验证过程中生成的错误信息按照字段名提取出来。</p>

<p>这里我们还第一次遇到了流程控制语句：<code>if</code>，它和<code>let</code>一样是一种“特殊形式(Special Form)”。它的一般格式是<code>(if 布尔型 语句1 语句2)</code>，如<code>(if (&gt; 1 2) (println true) (println false))</code>。如果语句包含多行怎么办？可以使用<code>do</code>函数。如果条件分支只有一个，则可以使用<code>when</code>和<code>when-not</code>，这时可以直接包含多行语句，不需要使用<code>do</code>。以下是一些示例：</p>

<p>```clojure
(if (> 1 2)
  (do</p>

<pre><code>(println 1)
(println 2))
</code></pre>

<p>  (println 3)) ;-> 3</p>

<p>(when (&lt; 1 2)
  (println 1)
  (println 2)) ;-> 1 \n 2
```</p>

<h3>错误提示</h3>

<p>那如何实现这样的需求：如果表单验证不通过，则重新显示表单，加入用户之前提交的内容，并显示出错信息。要做到这一点，就需要使用两个新的函数，<code>vali/on-error</code>和<code>noir.core/render</code>，并对<code>/blog/add</code>页面做一些修改。</p>

<p>```clojure
(defpartial error-item [[first-error]]
  [:span.error first-error])</p>

<p>(defpage "/blog/add" {:as forms}
  (common/layout</p>

<pre><code>[:h1 "新建文章"]
(form-to [:post "/blog/add"]
         (label "title" "标题：")
         (text-field {:size 50} "title" (:title forms))
         (vali/on-error :title error-item) [:br]
         (label "content" "内容：")
         (text-area {:rows 20 :cols 50} "content" (:content forms))
         (vali/on-error :content error-item) [:br]
         (submit-button "提交"))))
</code></pre>

<p>; 此处省略valid?函数，它没有变化</p>

<p>(defpage [:post "/blog/add"] {:as forms}
  (if (valid? forms)</p>

<pre><code>(str "添加成功，文章标题是：" (:title forms))
(render "/blog/add" forms)))
</code></pre>

<p>```</p>

<p>先看<code>render</code>，它是Noir提供的一个函数，能够在页面中渲染另一个页面的内容，就像调用一个函数一样。这里我们则是在表单提交的页面里渲染了“新建文章”页面的内容，并将表单参数传递了过去。</p>

<p>对“新建文章”页面我们做了以下修改：</p>

<ul>
<li>接收参数，并作为<code>forms</code>变量保存这个map。</li>
<li>为<code>text-field</code>和<code>text-area</code>两个表单控件添加了默认值。</li>
<li>调用了<code>vali/on-error</code>函数，当某个字段包含错误信息时，它会调用第二个参数所指向的函数（这里是<code>error-item</code>），并将该字段的错误信息作为参数传递给这个函数。</li>
</ul>


<p><code>error-item</code>函数的功能很简单，将接受到的错误信息渲染成一个<code>&lt;span&gt;</code>标签展示出来。这里的<code>[:span.error ...]</code>会被解析成<code>&lt;span class="error"&gt;...&lt;/span&gt;</code>。至于<code>[[first-error]]</code>，它是一种对list对象的解构操作。前面我们看到在错误信息中，某个字段即使只有一条错误信息，也会以向量的形式保存。我们这里只需要每个字段的第一条错误信息，所以使用了这种形式。你可以这样重写<code>error-item</code>，效果是一样的：</p>

<p><code>clojure
(defpartial error-item [errors]
  [:span.error (first errors)])
</code></p>

<h2>操作数据库</h2>

<p>Clojure程序连接数据库可以使用<code>clojure.java.jdbc</code>这个类库，它能够操作MySQL、PostgreSQL、SQLite、MSSQL等。这里我们将演示如何连接MySQL数据库，因此除了<code>clojure.java.jdbc</code>外，还需要添加MySQL Connector依赖项：</p>

<p>```clojure
(defproject ...</p>

<pre><code>        :dependencies [...
                       [org.clojure/java.jdbc "0.2.3"]
                       [mysql/mysql-connector-java "5.1.6"]]
        ...)
</code></pre>

<p>```</p>

<p>为了保存博客文章，我们在本地MySQL服务中新建一个<code>blog_db</code>数据库，并赋予用户<code>blog_db</code>（密码相同）该库的所有权限。然后我们会建立一张article表，用于保存文章：</p>

<p><code>``mysql
$ mysql -uroot -p
mysql&gt; create database blog_db collate utf8_general_ci;
mysql&gt; grant all on blog_db.* to 'blog_db'@'localhost' identified by 'blog_db';
mysql&gt; CREATE TABLE</code>article` (</p>

<pre><code>-&gt;   `id` int(11) NOT NULL AUTO_INCREMENT,
-&gt;   `title` varchar(500) NOT NULL,
-&gt;   `content` text NOT NULL,
-&gt;   `user_id` int(11) NOT NULL,
-&gt;   `created` datetime NOT NULL,
-&gt;   PRIMARY KEY (`id`)
-&gt; ) ENGINE=InnoDB;
</code></pre>

<p>```</p>

<p>我们新建一个<code>src/blog/database.clj</code>文件，用来存放数据库连接信息：</p>

<p>```clojure
(ns blog.database)</p>

<p>(def db-spec {:classname "com.mysql.jdbc.Driver"</p>

<pre><code>          :subprotocol "mysql"
          :subname "//127.0.0.1:3306/blog_db?useUnicode=true&amp;characterEncoding=UTF-8"
          :user "blog_db"
          :password "blog_db"})
</code></pre>

<p>```</p>

<p>接着新建<code>src/blog/models/blog.clj</code>文件，编写插入记录的函数：</p>

<p>```clojure
(ns blog.models.blog
  (:require [clojure.java.jdbc :as sql])
  (:use [blog.database :only [db-spec]])
  (:import java.sql.Timestamp))</p>

<p>(defn add! [forms]
  (sql/with-connection db-spec</p>

<pre><code>(sql/insert-records "article"
  {:title (:title forms)
   :content (:content forms)
   :user_id 0
   :created (Timestamp. (System/currentTimeMillis))})))
</code></pre>

<p>```</p>

<p>最后，我们只需要在<code>src/blog/views/article.clj</code>中调用这个函数即可：</p>

<p>```clojure
(ns ...
  (:require ...</p>

<pre><code>        [blog.models.blog :as model-blog]))
</code></pre>

<p>(defpage [:post "/blog/add"] {:as forms}
  (if (valid? forms)</p>

<pre><code>(str "添加成功，文章编号是："
     (:generated_key (first (model-blog/add! forms))))
(render "/blog/add" forms)))
</code></pre>

<p>```</p>

<p>这里我们见到了<code>clojure.java.jdbc</code>命名空间下的两个函数：<code>with-connection</code>和<code>insert-records</code>。前者用来打开一个数据库连接，它的第一个参数可以是一个map，表示数据库的连接信息，也可以是字符串，还可以直接传递一个DataSource对象，这点我们会在如何使用连接池时讲解。当<code>with-connection</code>执行完毕时，数据库连接也会随之关闭。<code>insert-record</code>则用于插入一条或多条数据，第一个参数是数据表名，第二个参数开始则是将要插入的记录。这个函数的返回值你应该可以从<code>(:generated_key ...)</code>这段代码中猜出来。</p>

<p>注意，我们的数据表中有一个DATETIME类型的字段，它需要使用<code>java.sql.Timestamp</code>类型来赋值。Clojure中引入一个类可以使用<code>import</code>函数，<code>ns</code>宏提供了便捷的方式<code>:import</code>。当需要一次导入多个类时，可以使用<code>(:import (java.sql Timestamp Date Time))</code>。</p>

<h3>使用C3P0连接池</h3>

<p>在高性能网站中，频繁开关数据库连接不是个好主意，通常的方式是使用连接池。这里我们演示如何使用C3P0连接池。</p>

<ul>
<li>添加依赖项：<code>[c3p0 "0.9.1.2"]</code></li>
<li>修改<code>src/blog/database.clj</code>，添加以下代码：</li>
</ul>


<p>```clojure
(ns blog.database
  (:import com.mchange.v2.c3p0.ComboPooledDataSource))</p>

<p>(def db-spec ...) ; db-spec没有变化，此处省略</p>

<p>(def pool
  (let [cpds (doto (ComboPooledDataSource.)</p>

<pre><code>           (.setDriverClass (:classname db-spec))
           (.setJdbcUrl (str "jdbc:" (:subprotocol spec) ":" (:subname db-spec)))
           (.setUser (:user db-spec))
           (.setPassword (:password db-spec)))]
{:datasource cpds}))
</code></pre>

<p>```</p>

<ul>
<li>更换<code>src/blog/models/blog.clj</code>中<code>with-connection</code>的参数：</li>
</ul>


<p>```clojure
(ns ...
  (:use [blog.database :only [pool]]))</p>

<p>(defn add! [forms]
  (sql/with-connection pool</p>

<pre><code>...))
</code></pre>

<p>```</p>

<p><code>with-connection</code>接收到的参数形式是<code>{:datasource DataSource接口的实例}</code>，<code>(ComboPooledDataSource.)</code>就是这样的一个实例，这种语法和<code>(new ComboPooledDataSource)</code>等价。<code>doto</code>函数表示连续调用第一个参数所指向的对象的方法，最后返回这个对象。这段代码可以有不同的写法，如<code>(def pool {:datasource (doto (Combo...))})</code>。</p>

<h2>小结</h2>

<p>这一章我们学习了如何配置Eclipse以编写Leiningen项目；如何使用表单和接受参数，特别是表单验证和错误信息的提示；最后我们演示了如何将数据保存到MySQL中，并使用连接池来优化项目。下一节我们将为博客增加用户登录的功能，以讲解Cookie和Session的使用。我们还会学习如何对Leiningen项目进行打包和发布，并尝试将我们的博客发布到PaaS平台Heroku上去。</p>
]]></content>
  </entry>
  
</feed>
