<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: guide | Anjuke Engineering]]></title>
  <link href="http://arch.corp.anjuke.com/blog/categories/guide/atom.xml" rel="self"/>
  <link href="http://arch.corp.anjuke.com/"/>
  <updated>2014-05-16T12:04:18+08:00</updated>
  <id>http://arch.corp.anjuke.com/</id>
  <author>
    <name><![CDATA[Anjuke Inc.]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Readme驱动开发]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2012/07/09/readme-driven-development/"/>
    <updated>2012-07-09T14:36:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2012/07/09/readme-driven-development</id>
    <content type="html"><![CDATA[<p><img class="right" src="http://0.gravatar.com/avatar/ce1e13bbf946c92e2abf740f8909bafa"></p>

<p>中文翻译：<a href="https://twitter.com/AReverie">陈磊</a> AReverie<br/>
英文原文：<a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html">Tom Preston-Werner</a></p>

<p>我最近听到很多关于测试驱动开发、行为驱动开发、极限编程和<a href="http://zh.wikipedia.org/wiki/Scrum" title="SCRUM">SCRUM</a> 、<a href="http://zh.wikipedia.org/wiki/Scrum#Scrum.E4.BC.9A.E8.AE.AE" title="站立会议">站立会议</a> 以及其他一切如何开发出更好的软件的各种方法论及技术，然而除非开发出来的软件满足使用者的需求，否则都是一纸空谈。我换种说法吧，对于错误规格的完美实现毫无价值可言。基于同样的原则，一座没有书卷而华丽修缮的图书馆也近乎无用。如果你的软件没有解决正确的问题或者根本没人知道它到底干嘛的，那可就不好玩了。</p>

<p>很好，那我们怎么解决这个问题呢？实际上比你想的要来的简单，并且其重要都足以单独列出一段。</p>

<p><strong>先写Readme</strong></p>

<p>首先，就像前面说的，在你动手写任何代码、测试、行为或者情景甚至任何东西前。别急别急，我明白我们都是程序猿，不是技术文枪手！但这就是你没想明白的地方。为一个软件写Readme着实非常有必要性。在给你的软件写点什么东西前，你根本不知道你要编写什么样的代码。在人人喊打的瀑布型设计和人见人爱的敏捷开发之间，我们似乎漏了点什么。别误会，瀑布型设计代价太大。它能把一个细致入微的庞大系统变成一个细致入微却全盘错误的系统。当初砍掉它是个正确的做法，但做法却矫枉过正。如今我们的项目里只有短小、糟糕的文档甚至完全不见踪影。你能想象有些项目完全没有Readme吗！</p>

<p>简直难以接受！在成堆的技术规格和完全没规格之间，必然会有个平衡点。那个平衡点就是朴素简明的Readme。</p>

<p>将Readme驱动开发（下文简称RDD）区别于文档驱动开发（下文简称DDD）十分重要。RDD可以理解成DDD的一个有限版本或子集。通过将你的设计文档精简成一个旨在介绍软件的单个文件，RDD能帮助你免于重蹈DDD而出现的瀑布型开发过程中出现冗长而过分细致的规格。同时，它能帮助你保持库的精简和模块化。这样一个简单的方法能帮助您免去繁琐的流程保证项目朝着正确的方向前进。</p>

<p>通过写第一个Readme，您能受益于以下这些显著的优势:</p>

<ul>
<li><p>最为重要的一点是，您给于了自己一次重新审视项目，又无需每次为了改变主意而去修改代码而花去开销的机会，例如整体应该如何组织、公用API里到底应该包含哪些东西。还记得您第一次写自动化测试代码，意识到揪出全部的错误从而防止那些问题悄悄跑进代码里去吗？在项目真正编码前写一个Reame的感觉是如出一辙的。</p></li>
<li><p>为了明确应该实现什么而去写Readme会产生一些副产品，您会得到一份写的非常棒的文档。当您在项目伊始，也就是兴奋度和动机处于最高的阶段，写一个文档会十分容易。事后再补Readme将是一种绝对的障碍，并且您会发现遗漏了许多重要的细节。</p></li>
<li><p>如果您与一群开发者一起协同工作，将会发现会从Readme收益颇多。如果其他成员在您尚未完成项目前便可以读到这份Readme，他们将大可放心的在将与您项目有交互的代码上开始工作。如果没有预先定义好的接口，团队只能顺序地编码或者面临重新实现大量代码的窘境。</p></li>
<li><p>基于白纸黑字的讨论将会容易的多，而在一个没有任何成文内容的讨论话题上，事情往往会演变成争论不休。把建议的解决方案写下来这样一个简单的行动，代表了一个具体的想法，从而能被讨论，迭代发展下去。</p></li>
</ul>


<p>把给您项目写Readme的过程当作一种真正的创造活动吧，这是您充满闪光的想法应该被表达的地方，这份文件的本意应当是阐述您的创造力和表现力。Readme应当是您代码中最为重要的一个文档，适当的做法就是首先写Readme。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Twelve-Factor App]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2012/05/09/the-twelve-factor-app/"/>
    <updated>2012-05-09T17:48:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2012/05/09/the-twelve-factor-app</id>
    <content type="html"><![CDATA[<p><img class="right" src="http://0.gravatar.com/avatar/7cdf5b1c46308979e3bf81390b0c8639"></p>

<p>中文翻译：<a href="https://github.com/liangshan/">梁山</a>
英文原文：<a href="http://www.12factor.net/">Adam Wiggins</a></p>

<p><em><a href="https://github.com/anjuke/12factor/issues">翻译问题反馈</a></em></p>

<h4>简介</h4>

<p>如今，软件通常会作为一种服务来交付，它们被称为“互联网应用程序”（web apps），或“软件即服务”（SaaS）。这篇“<strong><em>互联网应用的十二要素</em></strong>”为构建如下的互联网应用程序提供了指导方法：</p>

<ul>
<li>使用<strong>标准化</strong>流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目；</li>
<li>和操作系统之间尽可能的<strong>划清界限</strong>，在各个系统中提供<strong>最大的可移植性</strong>；</li>
<li>适合<strong>部署</strong>在现代的<strong>云计算平台</strong>，从而在服务器和系统管理方面节省资源；</li>
<li>将开发环境和生产环境的<strong>差异降至最低</strong>，并使用<strong>持续交付</strong>实施敏捷开发；</li>
<li>可以在工具、架构和开发流程不发生明显变化的前提下实现<strong>扩展</strong>；</li>
</ul>


<p>这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。</p>

<h4>背景</h4>

<p>本文的贡献者参与过数以百计的应用程序的开发和部署，并通过<a href="http://www.heroku.com/">Heroku</a>平台间接见证了数十万应用程序的开发，运作以及扩展的过程。</p>

<p>本文综合了我们关于SaaS应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何<a href="http://blog.heroku.com/archives/2011/6/28/the_new_heroku_4_erosion_resistance_explicit_contracts/">避免软件污染</a>。</p>

<p>我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。本文格式的灵感来自于Martin Fowler的书籍：<a href="http://books.google.com/books/about/Patterns_of_enterprise_application_archi.html?id=FyWZt5DdvFkC"><em>Patterns of Enterprise Application Architecture</em></a>，<a href="http://books.google.com/books/about/Refactoring.html?id=1MsETFPD3I0C"><em>Refactoring</em></a>。</p>

<h4>读者应该是哪些人？</h4>

<p>任何SaaS应用的开发人员；部署和管理此类应用的运维工程师。</p>

<!-- more -->


<h2>I. 基准代码</h2>

<p><strong><em>一份基准代码（<em>Codebase</em>)，多份部署(<em>deploy</em>)</em></strong></p>

<p>12-Factor App(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如<a href="http://git-scm.com/">Git</a>, <a href="http://mercurial.selenic.com/">Mercurial</a>, <a href="http://subversion.apache.org/">Subversion</a>。一份用来跟踪代码所有修订版本的数据库被称作 <em>代码库</em> （code repository, code repo, repo）。</p>

<p>在类似SVN这样的集中式版本控制系统中， <em>基准代码</em> 就是指控制系统中的这一份代码库；而在Git那样的分布式版本控制系统中， <em>基准代码</em> 则是指最上游的那份代码库。</p>

<p><img src="/medias/20120509/codebase-deploys.png" alt="一份代码库对应多份部署" /></p>

<p>基准代码和应用之间总是保持一一对应的关系：</p>

<ul>
<li>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用12-Factor进行开发。</li>
<li>多个应用共享一份基准代码是有悖于12-Factor原则的。解决方案是将共享的代码拆分为独立的类库，然后使用<a href="#dependencies">依赖管理</a>策略去加载它们。</li>
</ul>


<p>尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 <em>部署</em> 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。</p>

<p>所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。</p>

<h2>II. 依赖</h2>

<p><strong><em>显式声明依赖关系(<em>dependency</em>)</em></strong></p>

<p>大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像Perl的<a href="http://www.cpan.org/">CPAN</a>或是Ruby的<a href="http://rubygems.org/">Rubygems</a>。通过打包系统安装的类库可以是系统级的（称之为"site packages"），或仅供某个应用程序使用，部署在相应的目录中（称之为"vendoring"或"bunding"）。</p>

<p><strong>12-Factor规则下的应用程序不会隐式依赖系统级的类库。</strong> 它一定通过 <em>依赖清单</em> ，确切地声明所有依赖项。此外，在运行过程中通过 <em>依赖隔离</em> 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。</p>

<p>例如，Ruby的<a href="http://gembundler.com/">Gem Bundler</a>使用<code>Gemfile</code>作为依赖项声明清单，使用<code>bundle exec</code>来进行依赖隔离。Python中则可分别使用两种工具 -- <a href="http://www.pip-installer.org/en/latest/">Pip</a>用作依赖声明，<a href="http://www.virtualenv.org/en/latest/">Virtualenv</a>用作依赖隔离。甚至C语言也有类似工具，<a href="http://www.gnu.org/s/autoconf/">Autoconf</a>用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足12-Factor规范。</p>

<p>显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 <em>构建命令</em> 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler下使用<code>bundle install</code>，而Clojure/<a href="https://github.com/technomancy/leiningen#readme">Leiningen</a>则是<code>lein deps</code>。</p>

<p>12-Factor应用同样不会隐式依赖某些系统工具，如ImageMagick或是<code>curl</code>。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。</p>

<h2>III. 配置</h2>

<p><strong><em>在环境中存储配置</em></strong></p>

<p>通常，应用的<em>配置</em>在不同<a href="#codebase">部署</a> (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：</p>

<ul>
<li>数据库，Memcached，以及其他<a href="#backing-services">后端服务</a>的配置</li>
<li>第三方服务的证书，如Amazon S3、Twitter等</li>
<li>每份部署特有的配置，如域名等</li>
</ul>


<p>有些应用在代码中使用常量保存配置，这与12-factor所要求的<strong>代码和配置严格分离</strong>显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。</p>

<p>判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。</p>

<p>需要指出的是，这里定义的"配置"并<strong>不</strong>包括应用的内部配置，比如Rails的<code>config/routes.rb</code>，或是使用<a href="http://www.springsource.org/">Spring</a>时<a href="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html">代码模块间的依赖注入关系</a>。这类配置在不同部署间不存在差异，所以应该写入代码。</p>

<p>另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像Rails的<code>config/database.yml</code> 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。</p>

<p><strong>12-Factor推荐将应用的配置存储于<em>环境变量</em>中</strong> (<em>env vars</em>, <em>env</em>) 。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如Java的属性配置文件）相比，环境变量与语言和系统无关。</p>

<p>配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的<code>development</code>、<code>test</code>和<code>production</code>环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如<code>staging</code>或<code>qa</code>。随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如<code>joes-staging</code>，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。</p>

<p>12-Factor应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。</p>

<h2>IV. 后端服务</h2>

<p><strong><em>把后端服务(<em>backing services</em>)当作附加资源</em></strong></p>

<p><em>后端服务</em> 是指程序运行所需要的通过网络调用的各种服务，如数据库(<a href="http://dev.mysql.com/">MySQL</a>，<a href="http://couchdb.apache.org/">CouchDB</a>)，消息/队列系统(<a href="http://www.rabbitmq.com/">RabbitMQ</a>，<a href="http://kr.github.com/beanstalkd/">Beanstalkd</a>)，SMTP邮件发送服务(<a href="http://www.postfix.org/">Postfix</a>)，以及缓存系统(<a href="http://memcached.org/">Memcached</a>)。</p>

<p>类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括SMTP(例如 <a href="http://postmarkapp.com/">Postmark</a>)，数据收集服务（例如 <a href="http://newrelic.com/">New Relic</a> 或 <a href="http://www.loggly.com/">Loggly</a>），数据存储服务（如<a href="http://http://aws.amazon.com/s3/">Amazon S3</a>），以及使用API访问的服务(例如 <a href="http://dev.twitter.com/">Twitter</a>, <a href="http://code.google.com/apis/maps/index.html">Google Maps</a>, <a href="http://www.last.fm/api">Last.fm</a>)。</p>

<p><strong>12-Factor应用不会区别对待本地或第三方服务。</strong> 对应用程序而言，两种都是附加资源，通过一个url或是其他存储在<a href="#config">配置</a>中的服务定位/服务证书来获取数据。12-Factor应用的任意<a href="#codebase">部署</a> ，都应该可以在不进行任何代码改动的情况下，将本地MySQL数据库换成第三方服务(例如 <a href="http://aws.amazon.com/rds/">Amazon RDS</a>)。类似的，本地SMTP服务应该也可以和第三方SMTP服务(例如Postmark)互换。上述2个例子中，仅需修改配置中的资源地址。</p>

<p>每个不同的后端服务是一份<em>资源</em>。例如，一个MySQL数据库是一个资源，两个MySQL数据库(用来数据分区)就被当作是2个不同的资源。12-factor应用将这些数据库都视作<em>附加资源</em>，并且与这些附加资源保持松耦合。</p>

<p><img src="/medias/20120509/attached-resources.png" alt="一种部署附加4个后端服务" /></p>

<p>部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 -- 整个过程都不需要修改代码。</p>

<h2>V. 构建，发布，运行</h2>

<p><strong><em>严格分离构建和运行</em></strong></p>

<p><a href="#codebase">基准代码</a> 转化为一份部署(非开发环境)需要以下三个阶段：</p>

<ul>
<li><em>构建阶段</em>是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包<a href="#dependencies">依赖项</a>，编译成二进制文件和资源文件。</li>
<li><em>发布阶段</em>会将构建的结果和当前部署所需<a href="#config">配置</a>相结合，并能够立刻在运行环境中投入使用。</li>
<li><em>运行阶段</em>（或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序<a href="#processes">进程</a>。</li>
</ul>


<p><img src="/medias/20120509/release.png" alt="代码被构建，然后和配置结合成为发布版本" /></p>

<p><strong>12-facfor应用严格区分构建、发布、运行这三个步骤。</strong> 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。</p>

<p>部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如，<a href="https://github.com/capistrano/capistrano/wiki">Capistrano</a>将所有发布版本都存储在一个叫<code>releases</code>的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的<code>rollback</code>命令可以很容易地实现回退版本的功能。</p>

<p>每一个发布版本必须对应一个唯一的发布ID，例如可以使用发布时的时间戳(<code>2011-04-06-20:32:17</code>)，亦或是一个增长的数字(<code>v100</code>) 。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。</p>

<p>新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。</p>

<h2>VI. 进程</h2>

<p><strong><em>以一个或多个无状态进程运行应用</em></strong></p>

<p>运行环境中，应用程序通常是以一个和多个<em>进程</em>运行的。</p>

<p>最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行(例如<code>python my_script.py</code>)。另外一个极端情况是，复杂的应用可能会使用很多<a href="#concurrency">进程类型</a>，也就是零个或多个进程实例。</p>

<p><strong>12-factor应用的进程必须无状态且<a href="http://en.wikipedia.org/wiki/Shared_nothing_architecture">无共享</a> 。</strong> 任何需要持久化的数据都要存储在<a href="#backing-services">后端服务</a>内，比如数据库。</p>

<p>内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。</p>

<p>源文件打包工具(<a href="http://documentcloud.github.com/jammit/">Jammit</a>, <a href="http://code.google.com/p/django-assetpackager/">django-assetpackager</a>) 使用文件系统来缓存编译过的源文件。12-factor应用更倾向于在<a href="#build-release-run">构建步骤</a> 做此动作——正如<a href="http://ryanbigg.com/guides/asset_pipeline.html">Rails资源管道</a>，而不是在运行阶段。</p>

<p>一些互联网系统依赖于<a href="http://en.wikipedia.org/wiki/Load_balancing_%28computing%29#Persistence">“粘性session”</a>，这是指将用户session中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性Session是twelve-factor极力反对的。Session中的数据应该保存在诸如<a href="http://memcached.org/">Memcached</a>或<a href="http://redis.io/">Redis</a>这样的带有过期时间的缓存中。</p>

<h2>VII. 端口绑定</h2>

<p><strong><em>通过端口绑定(<em>Port binding</em>)来提供服务</em></strong></p>

<p>互联网应用有时会运行于服务器的容器之中。例如PHP经常作为<a href="http://httpd.apache.org/">Apache HTTPD</a>的一个模块来运行，正如Java运行于<a href="http://tomcat.apache.org/">Tomcat</a> 。</p>

<p><strong>12-factor应用完全自我加载</strong>而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用<strong>通过端口绑定来提供服务</strong>，并监听发送至该端口的请求。</p>

<p>本地环境中，开发人员通过类似<code>http://localhost:5000/</code>的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。</p>

<p>通常的实现思路是，将网络服务器类库通过<a href="#dependencies">依赖声明</a> 载入应用。例如，Python的<a href="http://www.tornadoweb.org/">Tornado</a>、Ruby的<a href="http://code.macournoyer.com/thin/">Thin</a>、Java以及其他基于JVM语言的<a href="http://jetty.codehaus.org/jetty/">Jetty</a>。完全由<em>用户端</em>，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。</p>

<p>HTTP并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用<a href="http://xmpp.org/">XMPP</a>的<a href="http://www.ejabberd.im/">ejabberd</a>，以及使用<a href="http://redis.io/topics/protocol">Redis协议</a>的<a href="http://redis.io/">Redis</a>。</p>

<p>还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的<a href="#backing-services">后端服务</a>，调用方将服务方提供的相应URL当作资源存入<a href="#config">配置</a> 以备将来调用。</p>

<h2>VIII. 并发</h2>

<p><strong><em>通过进程模型进行扩展</em></strong></p>

<p>任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP进程作为Apache的子进程存在，随请求按需启动。Java进程则采取了相反的方式，在程序启动之初JVM就提供了一个超级进程储备了大量的系统资源(CPU和内存)，并通过多线程实现内部的并发管理。上述2个例子中，进程是开发人员可以操作的最小单位。</p>

<p><img src="/medias/20120509/process-types.png" alt="扩展表现为运行中的进程，工作多样性表现为进程类型。" /></p>

<p><strong>在12-factor应用中，进程是一等公民。</strong> 12-factor应用的进程主要借鉴于<a href="http://adam.heroku.com/past/2011/5/9/applying_the_unix_process_model_to_web_apps/">unix进程模型</a>。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的<em>进程类型</em>。例如，HTTP请求可以交给web进程来处理，而常驻的后台工作则交由worker进程负责。</p>

<p>这并不表示应用不能通过单个进程来处理并发，如使用VM运行时的线程机制，或是由<a href="http://rubyeventmachine.com/">EventMachine</a>、<a href="http://twistedmatrix.com/trac/">Twisted</a>、<a href="http://nodejs.org/">Node.js</a>等工具提供的异步/事件驱动模型。但是，单个VM的垂直扩展能力是有限的，所以应用必须能够扩展到多台物理机器上运行。</p>

<p>在需要对系统进行扩展时，进程模型的作用会大放异彩。<a href="#processes">12-factor应用的进程所具备的无共享，水平分区的特性</a>意味着增加并发处理能力会是一项简单而稳妥的操作。这些进程的类型以及每个类型中进程的数量就被称作<em>进程构成</em> 。</p>

<p>12-factor应用 <a href="http://dustin.github.com/2010/02/28/running-processes.html">不需要作为守护进程启动</a>或是写入PID文件。相反的，应该借助操作系统的进程管理器(例如<a href="http://upstart.ubuntu.com/">Upstart</a>，分布式的进程管理云平台，或在开发环境中使用类似<a href="http://blog.daviddollar.org/2011/05/06/introducing-foreman.html">Foreman</a>的工具)，来管理<a href="#logs">输出流</a>，应对进程崩溃，以及处理用户触发的重启和关闭操作。</p>

<h2>IX. 易处理</h2>

<p><strong><em>快速启动和优雅终止可最大化健壮性</em></strong></p>

<p><strong>12-factor应用的<a href="#processes">进程</a>是<em>可支配</em>的，意思是说它们可以瞬间开启或停止。</strong> 这有利于快速、弹性的伸缩应用，迅速部署变化的<a href="#codebase">代码</a>或<a href="#config">配置</a> ，稳健的部署应用。</p>

<p>进程应当追求<strong>最小启动时间</strong>。理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的<a href="#build-release-run">发布</a> 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。</p>

<p>进程<strong>一旦接收<a href="http://en.wikipedia.org/wiki/SIGTERM">终止信号(<code>SIGTERM</code>)</a>就会优雅的终止</strong>。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。</p>

<p>对于worker进程来说，优雅终止是指将当前任务退回队列。例如，<a href="http://www.rabbitmq.com/">RabbitMQ</a>中，worker可以发送一个<a href="http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack"><code>NACK</code></a>信号。<a href="http://kr.github.com/beanstalkd/">Beanstalkd</a>中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如<a href="https://github.com/collectiveidea/delayed_job#readme">Delayed Job</a>则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 <a href="http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29">可重复执行</a>，这主要由将结果包装进事务或是使重复操作<a href="http://en.wikipedia.org/wiki/Idempotence">幂等</a>来实现。</p>

<p>进程还应当<strong>在面对突然死亡时保持健壮</strong>，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如<a href="http://kr.github.com/beanstalkd/">Beanstalkd</a>，它可以在客户端断开或超时后自动退回任务。无论如何，12-factor应用都应该可以设计能够应对意外的、不优雅的终结。<a href="http://lwn.net/Articles/191059/">Crash-only design</a>将这种概念转化为<a href="http://couchdb.apache.org/docs/overview.html">合乎逻辑的理论</a>。</p>

<h2>X. 开发环境与线上环境等价</h2>

<p><strong><em>尽可能的保持开发，预发布，线上环境相同</em></strong></p>

<p>从以往经验来看，开发环境（即开发人员的本地<a href="#codebase">部署</a>）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：</p>

<ul>
<li><strong>时间差异：</strong> 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。</li>
<li><strong>人员差异：</strong> 开发人员编写代码，运维人员部署代码。</li>
<li><strong>工具差异：</strong> 开发人员或许使用Nginx，SQLite，OS X，而线上环境使用Apache，MySQL以及Linux。</li>
</ul>


<p><strong>12-factor应用想要做到<a href="http://www.avc.com/a_vc/2011/02/continuous-deployment.html">持续部署</a>就必须缩小本地与线上差异。</strong> 再回头看上面所描述的三个差异:</p>

<ul>
<li>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。</li>
<li>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。</li>
<li>缩小工具差异：尽量保证开发环境以及线上环境的一致性。</li>
</ul>


<p>将上述总结变为一个表格如下：</p>

<table>
  <tr>
    <th></th>
    <th>传统应用</th>
    <th>12-factor应用</th>
  </tr>
  <tr>
    <th>每次部署间隔</th>
    <td>数周</td>
    <td>几小时</td>
  </tr>
  <tr>
    <th>开发人员 vs 运维人员</th>
    <td>不同的人</td>
    <td>相同的人</td>
  </tr>
  <tr>
    <th>开发环境 vs 线上环境</th>
    <td>不同</td>
    <td>尽量接近</td>
  </tr>
</table>


<p><a href="#backing-services">后端服务</a> 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的<em>适配器</em>。下列表格提供了一些例子。</p>

<table>
  <tr>
    <th>类型</th>
    <th>语言</th>
    <th>类库</th>
    <th>适配器</th>
  </tr>
  <tr>
    <td>数据库</td>
    <td>Ruby/Rails</td>
    <td>ActiveRecord</td>
    <td>MySQL, PostgreSQL, SQLite</td>
  </tr>
  <tr>
    <td>队列</td>
    <td>Python/Django</td>
    <td>Celery</td>
    <td>RabbitMQ, Beanstalkd, Redis</td>
  </tr>
  <tr>
    <td>缓存</td>
    <td>Ruby/Rails</td>
    <td>ActiveSupport::Cache</td>
    <td>Memory, filesystem, Memcached</td>
  </tr>
</table>


<p>开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用SQLite线上使用PostgreSQL；又如本地缓存在进程内存中而线上存入Memcached。</p>

<p><strong>12-factor应用的开发人员应该反对在不同环境间使用不同的后端服务</strong>，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。</p>

<p>与此同时，轻量的本地服务也不像以前那样引人注目。借助于<a href="http://mxcl.github.com/homebrew/">Homebrew</a>，<a href="https://help.ubuntu.com/community/AptGet/Howto">apt-get</a>等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ等后端服务的安装与运行也并不复杂。此外，使用类似<a href="http://www.opscode.com/chef/">Chef</a>和<a href="http://docs.puppetlabs.com/">Puppet</a>的声明式配置工具，结合像<a href="http://vagrantup.com/">Vagrant</a>这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。</p>

<p>不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p>

<h2>XI. 日志</h2>

<p><strong><em>把日志当作事件流</em></strong></p>

<p><em>日志</em>使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。</p>

<p>日志应该是<a href="http://adam.heroku.com/past/2011/4/1/logs_are_streams_not_files/">事件流</a>的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。日志的原始形式通常是文本文件，一行一个事件（程序异常产生的跟踪信息会跨越多行）。日志没有确定开始和结束，但随着应用在运行会持续的增加。</p>

<p><strong>12-factor应用本身从不考虑存储自己的输出流。</strong> 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出(<code>stdout</code>)事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。</p>

<p>在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似<a href="https://github.com/heroku/logplex">Logplex</a>和<a href="https://github.com/fluent/fluentd">Fluent</a>的开源工具可以达到这个目的。</p>

<p>这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到<a href="http://www.splunk.com/">Splunk</a>这样的日志索引及分析系统，或<a href="http://hive.apache.org/">Hadoop/Hive</a>这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：</p>

<ul>
<li>找出过去一段时间特殊的事件。</li>
<li>图形化一个大规模的趋势，比如每分钟的请求量。</li>
<li>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。</li>
</ul>


<h2>XII. 管理进程</h2>

<p><strong><em>后台管理任务当作一次性进程运行</em></strong></p>

<p><a href="#concurrency">进程构成</a> 是指用来处理应用的常规业务(比如处理web请求)的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p>

<ul>
<li>运行数据移植（Django中的<code>manage.py syncdb</code>, Rails中的<code>rake db:migrate</code>）。</li>
<li>运行一个控制台（也被称为<a href="http://en.wikipedia.org/wiki/Read-eval-print_loop">REPL</a> shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个REPL工具(<code>python</code>或<code>erl</code>) ，或是其他命令（Ruby使用 <code>irb</code>, Rails使用 <code>rails console</code> ）。</li>
<li>运行一些提交到代码仓库的一次性脚本。</li>
</ul>


<p>一次性管理进程应该和正常的<a href="#processes">常驻进程</a>使用同样的环境。这些管理进程和任何其他的进程一样使用相同的<a href="#codebase">代码</a>和<a href="#config">配置</a>，基于某个<a href="#build-release-run">发布版本</a>运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p>

<p>所有进程类型应该使用同样的<a href="#dependencies">依赖隔离</a>技术。例如，如果Ruby的web进程使用了命令<code>bundle exec thin start</code>，那么数据库移植应使用<code>bundle exec rake db:migrate</code>。同样的，如果一个Python程序使用了Virtualenv，则需要在运行Tornado Web服务器和任何<code>manage.py</code>管理进程时引入‵bin/python‵ 。</p>

<p>12-factor尤其青睐那些提供了REPL shell的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用shell命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitCorp FAQ]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2012/04/24/gitcorp-faq/"/>
    <updated>2012-04-24T14:12:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2012/04/24/gitcorp-faq</id>
    <content type="html"><![CDATA[<h3>怎样获得自己的代码仓库目录?</h3>

<p>首先以公司的域用户登录<a href="http://git.corp.anjuke.com">GitCorp</a>站点，找到<a href="http://git.corp.anjuke.com/account/public_keys">管理SSH公钥</a>的页面。然后根据提示增加你的SSH公钥。提交之后，系统将创建和域用户名相同名称的目录，作为你的代码仓库的根目录。</p>

<p>GitCorp允许一个帐号拥有多个公钥，这样你可以在不同的机器上访问你的代码仓库而不需要共享私钥。</p>

<h3>怎样新建用户代码仓库?</h3>

<p>登录<a href="http://git.corp.anjuke.com">GitCorp</a>站点，选择"Repo"菜单，然后点击"New"按钮创建新的代码仓库。创建代码仓库名要求输入仓库名称($REPO)和描述，新的仓库将建立这你的个人目录($USER)下。</p>

<p>之后可以通过以下命令，将代码仓库克隆到本地。</p>

<pre><code>git clone git@git.corp.anjuke.com:($USER)/($REPO)
</code></pre>

<p>或者在本地已经有代码仓库了，就可以push到GitCorp的用户目录下。</p>

<pre><code>git remote add origin git@git.corp.anjuke.com:($USER)/($REPO)
git push origin master
</code></pre>

<!-- more -->


<h3>怎样删除用户代码仓库?</h3>

<p>登录<a href="http://git.corp.anjuke.com">GitCorp</a>站点，选择"Repo"菜单，然后进入要删除的仓库。选择"Admin"，可以看到"Delete"选项。</p>

<p>只能删除自己目录下的代码仓库。</p>

<h3>如何修改代码仓库在cgit/gitweb上的描述?</h3>

<p>登录<a href="http://git.corp.anjuke.com">GitCorp</a>站点，选择"Repo"菜单，然后进入要删除的仓库。选择"Admin"，可以修改仓库的描述。</p>

<h3>如何fork其他代码仓库?</h3>

<p>这<a href="http://git.corp.anjuke.com">GitCorp</a>站点提供Fork功能之前，必须首先将其他代码仓库clone到本地，然后push到自己的代码仓库。</p>

<pre><code>git clone --mirror ($GIT_REPO_URL) ($LOCAL_REPO)
cd ($LOCAL_REPO)
git remote add gitcorp git@git.corp.anjuke.com:($USER)/($REPO)
git push --mirror gitcorp
</code></pre>

<p>注意：在push之前需要通过Web界面先创建一个空的仓库。</p>

<h3>如何merge其他工程师的改进到自己的代码仓库?</h3>

<p>假设自己的代码仓库在<code>git@git.corp.anjuke.com:my/repo.git</code>，另一工程师的代码仓库在<code>git@git.corp.anjuke.com:peer/repo.git</code>。</p>

<p>首先将自己的代码仓库clone到本地</p>

<pre><code>git clone git@git.corp.anjuke.com:my/repo.git
cd repo.git
</code></pre>

<p>增加对方的代码仓库，并获取更新</p>

<pre><code>git remote add peer git@git.corp.anjuke.com:peer/repo.git
git fetch peer
</code></pre>

<p>然后就可以merge对方的代码，例如</p>

<pre><code>git checkout master
git merge --no-commit peer/master
</code></pre>

<p>最后将合并好的代码push到自己的代码仓库</p>

<pre><code>git push origin master
</code></pre>

<h3>如何直接将改动push到其他人的代码仓库?</h3>

<p>这需要对方用户代码仓库的写权限，因此要对方操作，开放该代码仓库的写权限。</p>

<p>改变仓库的权限可以通过Web界面进行。登录<a href="http://git.corp.anjuke.com">GitCorp</a>站点，选择"Repo"菜单，然后进入要修改的仓库。选择"Admin"，可以给其他用户赋予写权限。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitCorp Flow - 安居客Git开发流程建议]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2012/02/28/gitcorp-flow-recommendation/"/>
    <updated>2012-02-28T09:13:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2012/02/28/gitcorp-flow-recommendation</id>
    <content type="html"><![CDATA[<p>这里我们说一下使用gitcorp来进行源代码管理的开发流程建议。在gitcorp里，每个工程师都可以创建自己的个人目录。除了个人目录外，有这么几个"官方"原始代码仓库</p>

<ul>
<li><a href="http://git.corp.anjuke.com/cgit/anjuke">anjuke</a></li>
<li><a href="http://git.corp.anjuke.com/cgit/aifang">aifang</a></li>
<li><a href="http://git.corp.anjuke.com/cgit/haozu">haozu</a></li>
<li><a href="http://git.corp.anjuke.com/cgit/jinpu">jinpu</a></li>
<li><a href="http://git.corp.anjuke.com/cgit/mobile">mobile</a></li>
<li><a href="http://git.corp.anjuke.com/cgit/corp">corp</a></li>
</ul>


<h2>代码仓库 - Git Repositories</h2>

<h3>原始代码仓库</h3>

<p>在这篇文章的例子中，我们以<code>git@git.corp.anjuke.com:corp/flow-demo.git</code>为原始代码仓库。文章后面提到的origin都是指原始代码仓库。</p>

<p>origin上只包含有正式的分支，例如: <strong>master</strong>，<strong>beta</strong>和<strong>ga</strong>。</p>

<ul>
<li><p><strong>master</strong>
主要的开发分支，待发布的新功能都在这个分支上。通常对这个分支进行每日构建、集成测试等；新的功能开发也都在这个分支的基础上进行。</p></li>
<li><p><strong>beta</strong>
这个分支将发布到预发布环境，通常其HEAD指向当前的预发布版本。在确定需要发布代码到预发布环境时，将代码从master分支合并到beta分支。</p></li>
<li><p><strong>ga</strong>
这个分支将发布到对外公开的环境，通常其HEAD指向当前的对外公开版本。在确定预发布版本可以对外公开时，将代码从beta分支合并到ga分支。</p></li>
</ul>


<!-- more -->


<h3>本地开发仓库</h3>

<p>当我们进行项目开发的时候，需要将origin克隆到本地，这时我们称呼本地的git仓库为本地开发仓库。下面这个命令将原始的<code>flow-demo.git</code>克隆到本地。</p>

<pre><code>$ git clone git@git.corp.anjuke.com:corp/flow-demo.git
</code></pre>

<p>在本地仓库查看所有分支</p>

<pre><code>$ git branch -a
</code></pre>

<p>将显示</p>

<pre><code>* master
  remotes/origin/beta
  remotes/origin/ga
  remotes/origin/master
</code></pre>

<h3>共享开发仓库</h3>

<p>当我们有项目需要多人共同开发时，又希望其他合作者可以直接push代码，可以设置共享仓库。</p>

<h4>创建共享仓库</h4>

<p>例如想要将的本地仓库推到服务器上，</p>

<pre><code>$ git remote add enzhang git@git.corp.anjuke.com:enzhang/flow-demo.git
$ git push enzhang master:master
</code></pre>

<p>者两个命令的格式是，</p>

<ul>
<li><code>git remote add (共享仓库的名字) (共享仓库的地址)</code></li>
<li><code>git push (共享仓库的名字) (要推送的本地的分支):(推送到远程仓库上的分支)</code></li>
</ul>


<p>其中<strong>共享仓库名</strong>在GitCorp环境下建议使用开发者的用户名，或者开发者的用户名为前缀</p>

<p>缺省情况下，这个共享仓库还只有创建者一个人有写权限，希望其他同事可以直接推送代码，还需要设置权限。可以先查看现有的用户权限</p>

<pre><code>$ ssh git@git.corp.anjuke.com getperms enzhang/flow-demo.git
</code></pre>

<p>输出:</p>

<pre><code>READERS @all
</code></pre>

<p>上面的<code>getperms</code>命令看到所有人有读权限。下面我们在原有权限的基础上给所有人增加写权限，</p>

<pre><code>$ (ssh git@git.corp.anjuke.com getperms enzhang/flow-demo.git \
    &amp;&amp; echo "WRITERS @all") | \
    ssh git@git.corp.anjuke.com setperms enzhang/flow-demo.git
</code></pre>

<p>输出:</p>

<pre><code>New perms are:
READERS @all
WRITERS @all
</code></pre>

<p>现在所有人对这个共享的代码仓库都拥有读写权限了。</p>

<h4>使用共享仓库</h4>

<p>当你需要加入别人创建的共享代码仓库时，只需要将其共享仓库加入git的remote里。</p>

<pre><code>$ git remote add enzhang git@git.corp.anjuke.com:enzhang/flow-demo.git
</code></pre>

<p>建议使用对方的开发者目录名作为git的remote名称，这样同时加入多个开发者的共享仓库也不容易混淆。</p>

<p>遵守我们之前的约定，<strong>origin都应该指向原始代码仓库</strong>。</p>

<h2>项目开发 - Feature Development</h2>

<p>已经准备好了本地代码仓库，现在看看项目开发的具体流程。</p>

<h3>开发者信息</h3>

<p>对于公司的项目，建议采用真实姓名和公司的邮箱地址作为git用户的信息。</p>

<pre><code>$ git config user.name "张尔宁"
$ git config user.email "enzhang@anjuke.com"
</code></pre>

<h3>项目开发分支</h3>

<p>通常对代码的改进都应该在分支上进行，确认完成后再合并回去。特别是项目的开发，由于改动一般比较多，应该新建立一个对应该项目的分支。我们约定这个分支以PMT的编号开始，例如<code>pmt1001</code>。</p>

<p>正常的项目分支从<code>master</code>分支拉出，(本地的<code>master</code>分支，跟踪<code>origin/master</code>的)</p>

<pre><code>$ git checkout -b pmt1001 master
</code></pre>

<p>写代码，提交</p>

<pre><code>$ echo "这是PMT1001的文件" &gt; pmt1001.txt
$ git add pmt1001.txt
$ git commit -m "增加某功能"
</code></pre>

<p>再写代码，提交</p>

<pre><code>$ echo "增加了一项功能" &gt;&gt; pmt1001.txt
$ git commit -a -m "又增加了一项功能"
</code></pre>

<p>项目完成，合并回master，注意<code>--no-ff</code>参数。</p>

<pre><code>$ git checkout master
$ git merge --no-ff pmt1001 -m '项目pmt1001完成，合并回master'
</code></pre>

<p>此时<code>pmt1001</code>这个分支已经不用，可以删除了。</p>

<pre><code>$ git branch -d pmt1001
</code></pre>

<p>git的日志大致如下</p>

<pre><code>$ git log --graph --abbrev-commit --pretty=format:'%h -%d %s'

*   43fe646 - (HEAD, master) 项目pmt1001完成，合并回master
|\
| * 43a7407 - 增加了一项功能
| * 757c89e - 增加某功能
|/
* 0774825 - (origin/master) GitCorp Flow Demo Initial Version
</code></pre>

<p>将改动push回原始仓库</p>

<pre><code>$ git push origin master:master
</code></pre>

<h3>并行的项目</h3>

<p>同一时候会有很多个项目在并行开发，假设现在有两个并行的项目<code>pmt1002</code>和<code>pmt1003</code>。我们先从<code>master</code>创建两个项目分支</p>

<pre><code>$ git branch pmt1002 master
$ git branch pmt1003 master
</code></pre>

<p>然后在<code>pmt1002</code>分支里进行开发</p>

<pre><code>$ git checkout pmt1002
$ echo "这是PMT1002的文件" &gt; pmt1002.txt
$ git add pmt1002.txt
$ git commit -m '增加pmt1002文件'
$ echo "修改PMT1002的文件" &gt;&gt; pmt1002.txt
$ git commit -a -m '修改pmt1002文件'
</code></pre>

<p>同时，在<code>pmt1003</code>分支里进行开发</p>

<pre><code>$ git checkout pmt1003
$ echo "这是PMT1003的文件" &gt; pmt1003.txt
$ git add pmt1003.txt
$ git commit -m '增加pmt1003文件'
$ echo "修改PMT1003的文件" &gt;&gt; pmt1003.txt
$ git commit -a -m '修改pmt1003文件'
</code></pre>

<p>看有下两个分支的情况，<code>pmt1003</code></p>

<pre><code>$ git log pmt1003 --graph --abbrev-commit --pretty=format:'%h -%d %s'
* dad3119 - (HEAD, pmt1003) 修改pmt1003文件
* c69f390 - 增加pmt1003文件
*   43fe646 - (origin/master, master) 项目pmt1001完成，合并回master
|\
| * 43a7407 - 又增加了一项功能
| * 757c89e - 增加某功能
|/
* 0774825 - GitCorp Flow Demo Initial Version
</code></pre>

<p><code>pmt1002</code></p>

<pre><code>$ git log pmt1002 --graph --abbrev-commit --pretty=format:'%h -%d %s'
* e174508 - (pmt1002) 修改pmt1002文件
* b2698ed - 增加pmt1002文件
*   43fe646 - (origin/master, master) 项目pmt1001完成，合并回master
|\
| * 43a7407 - 又增加了一项功能
| * 757c89e - 增加某功能
|/
* 0774825 -  GitCorp Flow Demo Initial Version
</code></pre>

<p>这时<code>pmt1003</code>开发完毕，我们按照之前的流程，将<code>pmt1003</code>分支合并回<code>master</code>。</p>

<pre><code>$ git checkout master
$ git merge --no-ff pmt1003 -m '项目pmt1003完成，合并回master'
</code></pre>

<p>将得到这样的<code>master</code>分支</p>

<pre><code>$ git log --graph --abbrev-commit --pretty=format:'%h -%d %s'
*   2110b32 - (HEAD, master) 项目pmt1003完成，合并回master
|\
| * dad3119 - (pmt1003) 修改pmt1003文件
| * c69f390 - 增加pmt1003文件
|/
*   43fe646 - (origin/master) 项目pmt1001完成，合并回master
|\
| * 43a7407 - 又增加了一项功能
| * 757c89e - 增加某功能
|/
* 0774825 - GitCorp Flow Demo Initial Version
</code></pre>

<p>然后<code>pmt1002</code>继续开发</p>

<pre><code>$ git checkout pmt1002
$ echo "这是PMT1002的文件" &gt; pmt1003.txt
$ git add pmt1003.txt
$ git commit -m '创建了一个和pmt1003冲突的文件'
</code></pre>

<p>同样，<code>pmt1002</code>开发完毕，将<code>pmt1002</code>分支合并回<code>master</code></p>

<pre><code>$ git checkout master
$ git merge --no-ff pmt1002 -m '项目pmt1002完成，合并回master'
</code></pre>

<p>这时合并遇到冲突了。解决冲突后再提交。</p>

<pre><code>$ echo "这是PMT1003，PMT1002的共同文件" &gt; pmt1003.txt
$ git add pmt1003.txt
$ git commit -m '项目pmt1002完成，合并回master'
</code></pre>

<p>现在<code>master</code>分支的历史记录为</p>

<pre><code>$ git log --graph --abbrev-commit --pretty=format:'%h -%d %s'
*   f7c4c36 - (HEAD, master) 项目pmt1002完成，合并回master
|\
| * 6ec4909 - (pmt1002) 创建了一个和pmt1003冲突的文件
| * e174508 - 修改pmt1002文件
| * b2698ed - 增加pmt1002文件
* |   2110b32 - 项目pmt1003完成，合并回master
|\ \
| |/
|/|
| * dad3119 - (pmt1003) 修改pmt1003文件
| * c69f390 - 增加pmt1003文件
|/
*   43fe646 - (origin/master) 项目pmt1001完成，合并回master
|\
| * 43a7407 - 又增加了一项功能
| * 757c89e - 增加某功能
|/
* 0774825 - GitCorp Flow Demo Initial Version
</code></pre>

<p>分支合并的线路图显示，<code>pmt1003</code>分支从<code>43fe646</code>开始，合并到<code>2110b32</code>；<code>pmt1002</code>分支也从<code>43fe646</code>开始，合并到<code>f7c4c36</code></p>

<h3>rebase</h3>

<p>除了直接合并回<code>master</code>，还可以选择在项目分支内先进行<strong>rebase</strong>再合并回去的方法。我们先将<code>master</code>分支回退到<code>pmt1002</code>合并前的状态</p>

<pre><code>$ git reset --hard 2110b32
</code></pre>

<p>然后采用在分支<code>pmt1001</code>下执行rebase</p>

<pre><code>$ git checkout pmt1002
$ git rebase master
</code></pre>

<p>一样会遇到合并冲突，着手解决后继续</p>

<pre><code>$ echo "这是PMT1003，PMT1002的共同文件" &gt; pmt1003.txt
$ git add pmt1003.txt
$ git rebase --continue
</code></pre>

<p>完成后<code>pmt1002</code>的分支成为</p>

<pre><code>$ git log --graph --abbrev-commit --pretty=format:'%h -%d %s'
* b0fe0ac - (HEAD, pmt1002) 创建了一个和pmt1003冲突的文件
* e402ad1 - 修改pmt1002文件
* 48faf83 - 增加pmt1002文件
*   2110b32 - (master) 项目pmt1003完成，合并回master
|\
| * dad3119 - (pmt1003) 修改pmt1003文件
| * c69f390 - 增加pmt1003文件
|/
*   43fe646 - (origin/master) 项目pmt1001完成，合并回master
|\
| * 43a7407 - 又增加了一项功能
| * 757c89e - 增加某功能
|/
* 0774825 - GitCorp Flow Demo Initial Version
</code></pre>

<p>这时再将<code>pmt1002</code>分支合并回<code>master</code></p>

<pre><code>$ git checkout master
$ git merge --no-ff pmt1002 -m '项目pmt1002完成，合并回master'
</code></pre>

<p>此时，<code>master</code>分支为</p>

<pre><code>$ git log --graph --abbrev-commit --pretty=format:'%h -%d %s'
*   b42d61d - (HEAD, master) 项目pmt1002完成，合并回master
|\
| * b0fe0ac - (pmt1002) 创建了一个和pmt1003冲突的文件
| * e402ad1 - 修改pmt1002文件
| * 48faf83 - 增加pmt1002文件
|/
*   2110b32 - 项目pmt1003完成，合并回master
|\
| * dad3119 - (pmt1003) 修改pmt1003文件
| * c69f390 - 增加pmt1003文件
|/
*   43fe646 - (origin/master) 项目pmt1001完成，合并回master
|\
| * 43a7407 - 又增加了一项功能
| * 757c89e - 增加某功能
|/
* 0774825 - GitCorp Flow Demo Initial Version
</code></pre>

<p>这里rebase的优点是，冲突在项目的分支里解决，并且<code>master</code>上图看起来比较清晰。</p>

<p>不再使用的分支应该删掉</p>

<pre><code>$ git branch -d pmt1002 pmt1003
</code></pre>

<p><strong>注意</strong>: 已经push到服务器上的commits不应该再改动，否则再改动之前已经fetch这些commits的同事可能遇到麻烦。</p>

<h3>多人共同开发一个项目</h3>

<p>现在来说一下，多个人共同开发一个项目分支的情况。这在我们平时的项目开发中是最常见的一种情况。</p>

<pre><code>        /------------\    +------------+      +------------+ +------------+
        | origin     |    | enzhang    |      | bob        | | alice      |
        |  * master  |    |  * master  |  ... |  * master  | |  * master  |
        |  * beta    |    |  - pmt1004 |      |  - pmt1005 | |  - pmt1006 |
        |  * ga      |    |            |      |            | |            |
        \------------/    +------------+      +------------+ +------------+
         origin repo \    / shared repo         shared repo    shared repo
              |       \  /       |
              |        \/        |
              |        /\        |
              |       /  \       |
 local repo   |      /    \      |    local repo
+--------------------+    +---------------------+
| enzhang            |    | liangshan           |
|  * master          |    |   * master          |
|  - pmt1004         |    |   - pmt1004         |
|  * origin/master   |    |   * origin/master   |
|  * enzhang/master  |    |   * enzhang/master  |
|  * enzhang/pmt1004 |    |   * enzhang/pmt1004 |
+--------------------+    +---------------------+
</code></pre>

<p>举例开发项目<code>pmt1004</code>。</p>

<p>enzhang首先开始。如果之前的例子，首先在本地仓库建立<code>pmt1004</code>分支</p>

<pre><code>$ git checkout -b pmt1004 master
</code></pre>

<p>将需要共同开发的项目分支推送到共享代码仓库中 (假设共享的代码仓库之前已经设置好)</p>

<pre><code>$ git push enzhang pmt1004:pmt1004
</code></pre>

<p>并通知合作伙伴liangshan，在共享仓库的<code>pmt1004</code>分支下一起开发。同时自己还在继续进行开发</p>

<pre><code>$ echo "PMT1004" &gt; pmt1004.txt
$ git add pmt1004.txt
$ git commit -m '完成pmt1004第一个功能点'
$ echo "PMT1004.balabala" &gt;&gt; pmt1004.txt
$ git commit -a -m '完成pmt1004第二个功能点'
</code></pre>

<p>假设liangshan已经从原始仓库clone了一份代码，如果还没有需要执行</p>

<pre><code>$ git clone git@git.corp.anjuke.com:corp/flow-demo.git
</code></pre>

<p>liangshan在接到共享的开发分支位置后，开始工作</p>

<pre><code>$ git remote add enzhang git@git.corp.anjuke.com:enzhang/flow-demo.git
$ git fetch enzhang
$ git checkout -b pmt1004 enzhang/pmt1004
$ echo "PMT1004" &gt; pmt1004.ls.txt
$ git add pmt1004.ls.txt
$ git commit -m '完成pmt1004第三个功能点'
$ echo "PMT1004.balabala" &gt;&gt; pmt1004.ls.txt
$ git commit -a -m '完成pmt1004第四个功能点'
</code></pre>

<p>这时，enzhang将本地的最新修改push到共享仓库</p>

<pre><code>$ git push enzhang pmt1004
</code></pre>

<p>之后，liangshan也将最新的修改push到共享仓库</p>

<pre><code>$ git push enzhang pmt1004
</code></pre>

<p>这时可以看到一窜错误提示，无法fast-forward合并</p>

<pre><code>To git@git.corp.anjuke.com:enzhang/flow-demo.git
 ! [rejected]        pmt1004 -&gt; pmt1004 (non-fast-forward)
error: failed to push some refs to 'git@git.corp.anjuke.com:enzhang/flow-demo.git'
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes (e.g. 'git pull') before pushing again.  See the
'Note about fast-forwards' section of 'git push --help' for details.
</code></pre>

<p>应该在本地先合并好再push到远程的共享仓库，并且建议使用rebase参数</p>

<pre><code>$ git pull --rebase enzhang
$ git push enzhang pmt1004
</code></pre>

<p>enzhang还继续在本来进行新的开发</p>

<pre><code>$ echo "PMT1004.foobar" &gt;&gt; pmt1004.txt
$ git commit -a -m '完成pmt1004第五个功能点'
</code></pre>

<p>当enzhang需要push代码到共享仓库的时候，同样需要pull再push</p>

<pre><code>$ git pull --rebase enzhang
$ git push enzhang
</code></pre>

<p>现在项目开发完成，由liangshan来负责合并代码到<code>master</code>分支</p>

<pre><code>$ git fetch --all
$ git checkout pmt1004
$ git rebase enzhang/pmt1004
$ git checkout master
$ git rebase origin/master
$ git merge pmt1004 --no-ff -m '项目pmt1004完成'
$ git push origin
</code></pre>

<p>由于项目<code>pmt1004</code>已经开发完毕，而且已经合并入<code>master</code>分支，可以删除这个分支了</p>

<pre><code>$ git branch -d pmt1004
</code></pre>

<p>enzhang的共享代码仓库里的pmt1004分支也可以删除</p>

<pre><code>$ git push enzhang :pmt1004
</code></pre>

<p>看看此时<code>master</code>分支的情况</p>

<pre><code>$ git log --graph --abbrev-commit --pretty=format:'%h -%d %s &lt;%an&gt;'
*   6f6cb8f - (HEAD, origin/master, master) 项目pmt1004完成 &lt;梁山&gt;
|\
| * fe42061 - 完成pmt1004第五个功能点 &lt;张尔宁&gt;
| * a581641 - 完成pmt1004第四个功能点 &lt;梁山&gt;
| * 35a2cc4 - 完成pmt1004第三个功能点 &lt;梁山&gt;
| * 3b92be2 - 完成pmt1004第二个功能点 &lt;张尔宁&gt;
| * 74746a5 - 完成pmt1004第一个功能点 &lt;张尔宁&gt;
|/
*   b42d61d - 项目pmt1002完成，合并回master &lt;张尔宁&gt;
|\
| * b0fe0ac - 创建了一个和pmt1003冲突的文件 &lt;张尔宁&gt;
| * e402ad1 - 修改pmt1002文件 &lt;张尔宁&gt;
| * 48faf83 - 增加pmt1002文件 &lt;张尔宁&gt;
|/
*   2110b32 - 项目pmt1003完成，合并回master &lt;张尔宁&gt;
|\
| * dad3119 - 修改pmt1003文件 &lt;张尔宁&gt;
| * c69f390 - 增加pmt1003文件 &lt;张尔宁&gt;
|/
*   43fe646 - 项目pmt1001完成，合并回master &lt;张尔宁&gt;
|\
| * 43a7407 - 又增加了一项功能 &lt;张尔宁&gt;
| * 757c89e - 增加某功能 &lt;张尔宁&gt;
|/
* 0774825 - GitCorp Flow Demo Initial Version
</code></pre>

<p>也可以仅查看在<code>master</code>分支上的提交</p>

<pre><code>$ git log --graph --abbrev-commit --pretty=format:'%h -%d %s &lt;%an&gt;' --first-parent
* 6f6cb8f - (HEAD, origin/master, master) 项目pmt1004完成 &lt;梁山&gt;
* b42d61d - 项目pmt1002完成，合并回master &lt;张尔宁&gt;
* 2110b32 - 项目pmt1003完成，合并回master &lt;张尔宁&gt;
* 43fe646 - 项目pmt1001完成，合并回master &lt;张尔宁&gt;
* 0774825 - GitCorp Flow Demo Initial Version
</code></pre>

<h2>代码发布</h2>

<p>各事业部具体代码发布的策略不尽相同。这里暂不描述发布的流程。</p>

<h3>BETA预发布</h3>

<p>BETA预发布我们定义为部署在正式的生成环境，由小部分可选择的真实用户访问的版本。</p>

<h3>GA正式发布</h3>

<p>GA版本我们定义为部署在正式的生成环境，对真实用户开发的版本。</p>

<h3>自定义版本的发布</h3>

<p>发布到正式环境以外的其他地方。一般为测试环境，例如功能测试环境等。</p>

<h3>hotfix</h3>

<p>hotfix一般为production bug，必须立即在非master分支(如beta/ga)上直接修改的。</p>

<p>hotfix的修改还需要合并回master分支。ga版本的hotfix修改可能还需要合并回beta。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown: Syntax]]></title>
    <link href="http://arch.corp.anjuke.com/blog/2012/02/27/markdown-syntax/"/>
    <updated>2012-02-27T18:29:00+08:00</updated>
    <id>http://arch.corp.anjuke.com/blog/2012/02/27/markdown-syntax</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md">文档来源</a></p>

<p><strong>NOTE:</strong> This is Traditional Chinese Edition Document of
Markdown Syntax. If you are seeking for English Edition
Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax">Markdown: Syntax</a>.</p>

<ul>
<li><a href="#overview">概述</a>

<ul>
<li><a href="#philosophy">哲學</a></li>
<li><a href="#html">行內 HTML</a></li>
<li><a href="#autoescape">特殊字元自動轉換</a></li>
</ul>
</li>
<li><a href="#block">區塊元素</a>

<ul>
<li><a href="#p">段落和換行</a></li>
<li><a href="#header">標題</a></li>
<li><a href="#blockquote">區塊引言</a></li>
<li><a href="#list">清單</a></li>
<li><a href="#precode">程式碼區塊</a></li>
<li><a href="#hr">分隔線</a></li>
</ul>
</li>
<li><a href="#span">區段元素</a>

<ul>
<li><a href="#link">連結</a></li>
<li><a href="#em">強調</a></li>
<li><a href="#code">程式碼</a></li>
<li><a href="#img">圖片</a></li>
</ul>
</li>
<li><a href="#misc">其它</a>

<ul>
<li><a href="#backslash">跳脫字元</a></li>
<li><a href="#autolink">自動連結</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感謝</a></li>
</ul>


<p><strong>注意：</strong>這份文件是用 Markdown 寫的，你可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md">看看它的原始檔</a> 。</p>

<hr />

<h2 id="overview">概述</h2>




<h3 id="philosophy">哲學</h3>


<p>Markdown 的目標是實現「易讀易寫」。</p>

<p>不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/">atx</a>、<a href="http://textism.com/tools/textile/">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/">EtText</a>，然而最大靈感來源其實是純文字的電子郵件格式。</p>

<p>因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像*強調*。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。</p>

<!-- more -->




<h3 id="html">行內 HTML</h3>


<p>Markdown 的語法有個主要的目的：用來作為一種網路內容的<em>寫作</em>用語言。</p>

<p>Markdown 不是要來取代 HTML，甚至也沒有要和它相似，它的語法種類不多，只和 HTML 的一部分有關係，重點<em>不是</em>要創造一種更容易寫作 HTML 文件的語法，我認為 HTML 已經很容易寫了，Markdown 的重點在於，它能讓文件更容易閱讀、編寫。HTML 是一種<em>發佈</em>的格式，Markdown 是一種<em>編寫</em>的格式，因此，Markdown 的格式語法只涵蓋純文字可以涵蓋的範圍。</p>

<p>不在 Markdown 涵蓋範圍之外的標籤，都可以直接在文件裡面用 HTML 撰寫。不需要額外標註這是 HTML 或是 Markdown；只要直接加標籤就可以了。</p>

<p>只有區塊元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等標籤，必需在前後加上空白，以利與內容區隔。而且這些（元素）的開始與結尾標籤，不可以用 tab 或是空白來縮排。Markdown 的產生器有智慧型判斷，可以避免在區塊標籤前後加上沒有必要的 <code>&lt;p&gt;</code> 標籤。</p>

<p>舉例來說，在 Markdown 文件裡加上一段 HTML 表格：</p>

<pre><code>This is a regular paragraph.

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

This is another regular paragraph.
</code></pre>

<p>請注意，Markdown 語法在 HTML 區塊標籤中將不會被進行處理。例如，你無法在 HTML 區塊內使用 Markdown 形式的<code>*強調*</code>。</p>

<p>HTML 的區段標籤如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 則不受限制，可以在 Markdown 的段落、清單或是標題裡任意使用。依照個人習慣，甚至可以不用Markdown 格式，而採用 HTML 標籤來格式化。舉例說明：如果比較喜歡 HTML 的  <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 標籤，可以直接使用這些標籤，而不用 Markdown 提供的連結或是影像標示語法。</p>

<p>HTML 區段標籤和區塊標籤不同，在區段標籤的範圍內， Markdown 的語法是有效的。</p>

<h3 id="autoescape">特殊字元自動轉換</h3>


<p>在 HTML 文件中，有兩個字元需要特殊處理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符號用於起始標籤，<code>&amp;</code> 符號則用於標記 HTML 實體，如果你只是想要使用這些符號，你必須要使用實體的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>

<p><code>&amp;</code> 符號其實很讓寫作網路文件的人感到困擾，如果你要打「AT&amp;T」 ，你必須要寫成「<code>AT&amp;amp;T</code>」 ，還得轉換網址內的 <code>&amp;</code> 符號，如果你要連結到：</p>

<pre><code>http://images.google.com/images?num=30&amp;q=larry+bird
</code></pre>

<p>你必須要把網址轉成：</p>

<pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird
</code></pre>

<p>才能放到連結標籤的 <code>href</code> 屬性裡。不用說也知道這很容易忘記，這也可能是 HTML 標準檢查所檢查到的錯誤中，數量最多的。</p>

<p>Markdown 允許你直接使用這些符號，但是你要小心跳脫字元的使用，如果你是在HTML 實體中使用 <code>&amp;</code> 符號的話，它不會被轉換，而在其它情形下，它則會被轉換成 <code>&amp;amp;</code>。所以你如果要在文件中插入一個著作權的符號，你可以這樣寫：</p>

<pre><code>&amp;copy;
</code></pre>

<p>Markdown 將不會對這段文字做修改，但是如果你這樣寫：</p>

<pre><code>AT&amp;T
</code></pre>

<p>Markdown 就會將它轉為：</p>

<pre><code>AT&amp;amp;T
</code></pre>

<p>類似的狀況也會發生在 <code>&lt;</code> 符號上，因為 Markdown 支援 <a href="#html">行內 HTML</a> ，如果你是使用 <code>&lt;</code> 符號作為 HTML 標籤使用，那 Markdown 也不會對它做任何轉換，但是如果你是寫：</p>

<pre><code>4 &lt; 5
</code></pre>

<p>Markdown 將會把它轉換為：</p>

<pre><code>4 &amp;lt; 5
</code></pre>

<p>不過需要注意的是，code 範圍內，不論是行內還是區塊， <code>&lt;</code> 和 <code>&amp;</code> 兩個符號都<em>一定</em>會被轉換成 HTML 實體，這項特性讓你可以很容易地用 Markdown 寫 HTML code （和 HTML 相對而言， HTML 語法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都轉換為 HTML 實體，才能在 HTML 文件裡面寫出 HTML code。）</p>

<hr />

<h2 id="block">區塊元素</h2>




<h3 id="p">段落和換行</h3>


<p>一個段落是由一個以上相連接的行句組成，而一個以上的空行則會切分出不同的段落（空行的定義是顯示上看起來像是空行，便會被視為空行。比方說，若某一行只包含空白和 tab，則該行也會被視為空行），一般的段落不需要用空白或斷行縮排。</p>

<p>「一個以上相連接的行句組成」這句話其實暗示了 Markdown 允許段落內的強迫斷行，這個特性和其他大部分的 text-to-HTML 格式不一樣（包括 MovableType 的「Convert Line Breaks」選項），其它的格式會把每個斷行都轉成 <code>&lt;br /&gt;</code> 標籤。</p>

<p>如果你<em>真的</em>想要插入 <code>&lt;br /&gt;</code> 標籤的話，在行尾加上兩個以上的空白，然後按 enter。</p>

<p>是的，這確實需要花比較多功夫來插入 <code>&lt;br /&gt;</code> ，但是「每個換行都轉換為 <code>&lt;br /&gt;</code>」的方法在 Markdown 中並不適合， Markdown 中 email 式的 <a href="#blockquote">區塊引言</a> 和多段落的 <a href="#list">清單</a> 在使用換行來排版的時候，不但更好用，還更好閱讀。</p>

<h3 id="header">標題</h3>


<p>Markdown 支援兩種標題的語法，<a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> 和 <a href="http://www.aaronsw.com/2002/atx/">atx</a> 形式。</p>

<p>Setext 形式是用底線的形式，利用 <code>=</code> （最高階標題）和 <code>-</code> （第二階標題），例如：</p>

<pre><code>This is an H1
=============

This is an H2
-------------
</code></pre>

<p>任何數量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>

<p>Atx 形式則是在行首插入 1 到 6 個 <code>#</code> ，對應到標題 1 到 6 階，例如：</p>

<pre><code># This is an H1

## This is an H2

###### This is an H6
</code></pre>

<p>你可以選擇性地「關閉」atx 樣式的標題，這純粹只是美觀用的，若是覺得這樣看起來比較舒適，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 數量也不用和開頭一樣（行首的井字數量決定標題的階數）：</p>

<pre><code># This is an H1 #

## This is an H2 ##

### This is an H3 ######
</code></pre>

<h3 id="blockquote">Blockquotes</h3>


<p>Markdown 使用 email 形式的區塊引言，如果你很熟悉如何在 email 信件中引言，你就知道怎麼在 Markdown 文件中建立一個區塊引言，那會看起來像是你強迫斷行，然後在每行的最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>Markdown 也允許你只在整個段落的第一行最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>區塊引言可以有階層（例如：引言內的引言），只要根據層數加上不同數量的 <code>&gt;</code> ：</p>

<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre>

<p>引言的區塊內也可以使用其他的 Markdown 語法，包括標題、清單、程式碼區塊等：</p>

<pre><code>&gt; ## This is a header.
&gt; 
&gt; 1.   This is the first list item.
&gt; 2.   This is the second list item.
&gt; 
&gt; Here's some example code:
&gt; 
&gt;     return shell_exec("echo $input | $markdown_script");
</code></pre>

<p>任何標準的文字編輯器都能簡單地建立 email 樣式的引言，例如 BBEdit ，你可以選取文字後然後從選單中選擇<em>增加引言階層</em>。</p>

<h3 id="list">清單</h3>


<p>Markdown 支援有序清單和無序清單。</p>

<p>無序清單使用星號、加號或是減號作為清單標記：</p>

<pre><code>*   Red
*   Green
*   Blue
</code></pre>

<p>等同於：</p>

<pre><code>+   Red
+   Green
+   Blue
</code></pre>

<p>也等同於：</p>

<pre><code>-   Red
-   Green
-   Blue
</code></pre>

<p>有序清單則使用數字接著一個英文句點：</p>

<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>

<p>很重要的一點是，你在清單標記上使用的數字並不會影響輸出的 HTML 結果，上面的清單所產生的 HTML 標記為：</p>

<pre><code>&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
</code></pre>

<p>如果你的清單標記寫成：</p>

<pre><code>1.  Bird
1.  McHale
1.  Parish
</code></pre>

<p>或甚至是：</p>

<pre><code>3. Bird
1. McHale
8. Parish
</code></pre>

<p>你都會得到完全相同的 HTML 輸出。重點在於，你可以讓 Markdown 文件的清單數字和輸出的結果相同，或是你懶一點，你可以完全不用在意數字的正確性。</p>

<p>如果你使用懶惰的寫法，建議第一個項目最好還是從 1. 開始，因為 Markdown 未來可能會支援有序清單的 start 屬性。</p>

<p>清單項目標記通常是放在最左邊，但是其實也可以縮排，最多三個空白，項目標記後面則一定要接著至少一個空白或 tab。</p>

<p>要讓清單看起來更漂亮，你可以把內容用固定的縮排整理好：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>但是如果你很懶，那也不一定需要：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果清單項目間用空行分開， Markdown 會把項目的內容在輸出時用 <code>&lt;p&gt;</code>
標籤包起來，舉例來說：</p>

<pre><code>*   Bird
*   Magic
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>但是這個：</p>

<pre><code>*   Bird

*   Magic
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>清單項目可以包含多個段落，每個項目下的段落都必須縮排 4 個空白或是一個 tab ：</p>

<pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果你每行都有縮排，看起來會看好很多，當然，再次地，如果你很懶惰，Markdown 也允許：</p>

<pre><code>*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You're
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
</code></pre>

<p>如果要在清單項目內放進引言，那 <code>&gt;</code> 就需要縮排：</p>

<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre>

<p>如果要放程式碼區塊的話，該區塊就需要縮排<em>兩次</em>，也就是 8 個空白或是兩個 tab：</p>

<pre><code>*   A list item with a code block:

        &lt;code goes here&gt;
</code></pre>

<p>當然，項目清單很可能會不小心產生，像是下面這樣的寫法：</p>

<pre><code>1986. What a great season.
</code></pre>

<p>換句話說，也就是在行首出現<em>數字-句點-空白</em>，要避免這樣的狀況，你可以在句點前面加上反斜線。</p>

<pre><code>1986\. What a great season.
</code></pre>

<h3 id="precode">程式碼區塊</h3>


<p>和程式相關的寫作或是標籤語言原始碼通常會有已經排版好的程式碼區塊，通常這些區塊我們並不希望它以一般段落文件的方式去排版，而是照原來的樣子顯示，Markdown 會用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 標籤來把程式碼區塊包起來。</p>

<p>要在 Markdown 中建立程式碼區塊很簡單，只要簡單地縮排 4 個空白或是 1 個 tab 就可以，例如，下面的輸入：</p>

<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre>

<p>Markdown 會轉換成：</p>

<pre><code>&lt;p&gt;This is a normal paragraph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a code block.
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>這個每行一階的縮排（4 個空白或是 1 個 tab），都會被移除，例如：</p>

<pre><code>Here is an example of AppleScript:

    tell application "Foo"
        beep
    end tell
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application "Foo"
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>一個程式碼區塊會一直持續到沒有縮排的那一行（或是文件結尾）。</p>

<p>在程式碼區塊裡面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 會自動轉成 HTML 實體，這樣的方式讓你非常容易使用 Markdown 插入範例用的 HTML 原始碼，只需要複製貼上，再加上縮排就可以了，剩下的 Markdown 都會幫你處理，例如：</p>

<pre><code>    &lt;div class="footer"&gt;
        &amp;copy; 2004 Foo Corporation
    &lt;/div&gt;
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class="footer"&amp;gt;
    &amp;amp;copy; 2004 Foo Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>程式碼區塊中，一般的 Markdown 語法不會被轉換，像是星號便只是星號，這表示你可以很容易地以 Markdown 語法撰寫 Markdown 語法相關的文件。</p>

<h3 id="hr">分隔線</h3>


<p>你可以在一行中用三個或以上的星號、減號、底線來建立一個分隔線，行內不能有其他東西。你也可以在星號中間插入空白。下面每種寫法都可以建立分隔線：</p>

<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre>

<hr />

<h2 id="span">區段元素</h2>




<h3 id="link">連結</h3>


<p>Markdown 支援兩種形式的連結語法： <em>行內</em>和<em>參考</em>兩種形式。</p>

<p>不管是哪一種，連結的文字都是用 [方括號] 來標記。</p>

<p>要建立一個行內形式的連結，只要在方塊括號後面馬上接著括號並插入網址連結即可，如果你還想要加上連結的 title 文字，只要在網址後面，用雙引號把 title 文字包起來即可，例如：</p>

<pre><code>This is [an example](http://example.com/ "Title") inline link.

[This link](http://example.net/) has no title attribute.
</code></pre>

<p>會產生：</p>

<pre><code>&lt;p&gt;This is &lt;a href="http://example.com/" title="Title"&gt;
an example&lt;/a&gt; inline link.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://example.net/"&gt;This link&lt;/a&gt; has no
title attribute.&lt;/p&gt;
</code></pre>

<p>如果你是要連結到同樣主機的資源，你可以使用相對路徑：</p>

<pre><code>See my [About](/about/) page for details.   
</code></pre>

<p>參考形式的連結使用另外一個方括號接在連結文字的括號後面，而在第二個方括號裡面要填入用以辨識連結的標籤：</p>

<pre><code>This is [an example][id] reference-style link.
</code></pre>

<p>你也可以選擇性地在兩個方括號中間加上空白：</p>

<pre><code>This is [an example] [id] reference-style link.
</code></pre>

<p>接著，在文件的任意處，你可以把這個標籤的連結內容定義出來：</p>

<pre><code>[id]: http://example.com/  "Optional Title Here"
</code></pre>

<p>連結定義的形式為：</p>

<ul>
<li>方括號，裡面輸入連結的辨識用標籤</li>
<li>接著一個冒號</li>
<li>接著一個以上的空白或 tab</li>
<li>接著連結的網址</li>
<li>選擇性地接著 title 內容，可以用單引號、雙引號或是括弧包著</li>
</ul>


<p>下面這三種連結的定義都是相同：</p>

<pre><code>[foo]: http://example.com/  "Optional Title Here"
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
</code></pre>

<p><strong>請注意：</strong>有一個已知的問題是 Markdown.pl 1.0.1 會忽略單引號包起來的連結 title。</p>

<p>連結網址也可以用方括號包起來：</p>

<pre><code>[id]: &lt;http://example.com/&gt;  "Optional Title Here"
</code></pre>

<p>你也可以把 title 屬性放到下一行，也可以加一些縮排，網址太長的話，這樣會比較好看：</p>

<pre><code>[id]: http://example.com/longish/path/to/resource/here
    "Optional Title Here"
</code></pre>

<p>網址定義只有在產生連結的時候用到，並不會直接出現在文件之中。</p>

<p>連結辨識標籤可以有字母、數字、空白和標點符號，但是並<em>不</em>區分大小寫，因此下面兩個連結是一樣的：</p>

<pre><code>[link text][a]
[link text][A]
</code></pre>

<p><em>預設的連結標籤</em>功能讓你可以省略指定連結標籤，這種情形下，連結標籤和連結文字會視為相同，要用預設連結標籤只要在連結文字後面加上一個空的方括號，如果你要讓 "Google" 連結到 google.com，你可以簡化成：</p>

<pre><code>[Google][]
</code></pre>

<p>然後定義連結內容：</p>

<pre><code>[Google]: http://google.com/
</code></pre>

<p>由於連結文字可能包含空白，所以這種簡化的標籤內也可以包含多個文字：</p>

<pre><code>Visit [Daring Fireball][] for more information.
</code></pre>

<p>然後接著定義連結：</p>

<pre><code>[Daring Fireball]: http://daringfireball.net/
</code></pre>

<p>連結的定義可以放在文件中的任何一個地方，我比較偏好直接放在連結出現段落的後面，你也可以把它放在文件最後面，就像是註解一樣。</p>

<p>下面是一個參考式連結的範例：</p>

<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        "Google"
  [2]: http://search.yahoo.com/  "Yahoo Search"
  [3]: http://search.msn.com/    "MSN Search"
</code></pre>

<p>如果改成用連結名稱的方式寫：</p>

<pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        "Google"
  [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
  [msn]:    http://search.msn.com/    "MSN Search"
</code></pre>

<p>上面兩種寫法都會產生下面的 HTML。</p>

<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href="http://google.com/"
title="Google"&gt;Google&lt;/a&gt; than from
&lt;a href="http://search.yahoo.com/" title="Yahoo Search"&gt;Yahoo&lt;/a&gt;
or &lt;a href="http://search.msn.com/" title="MSN Search"&gt;MSN&lt;/a&gt;.&lt;/p&gt;
</code></pre>

<p>下面是用行內形式寫的同樣一段內容的 Markdown 文件，提供作為比較之用：</p>

<pre><code>I get 10 times more traffic from [Google](http://google.com/ "Google")
than from [Yahoo](http://search.yahoo.com/ "Yahoo Search") or
[MSN](http://search.msn.com/ "MSN Search").
</code></pre>

<p>參考式的連結其實重點不在於它比較好寫，而是它比較好讀，比較一下上面的範例，使用參考式的文章本身只有 81 個字元，但是用行內形式的連結卻會增加到 176 個字元，如果是用純 HTML 格式來寫，會有 234 個字元，在 HTML 格式中，標籤比文字還要多。</p>

<p>使用 Markdown 的參考式連結，可以讓文件更像是瀏覽器最後產生的結果，讓你可以把一些標記相關的資訊移到段落文字之外，你就可以增加連結而不讓文章的閱讀感覺被打斷。</p>

<h3 id="em">強調</h3>


<p>Markdown 使用星號（<code>*</code>）和底線（<code>_</code>）作為標記強調字詞的符號，被 <code>*</code> 或 <code>_</code> 包圍的字詞會被轉成用 <code>&lt;em&gt;</code> 標籤包圍，用兩個 <code>*</code> 或 <code>_</code> 包起來的話，則會被轉成 <code>&lt;strong&gt;</code>，例如：</p>

<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre>

<p>會轉成：</p>

<pre><code>&lt;em&gt;single asterisks&lt;/em&gt;

&lt;em&gt;single underscores&lt;/em&gt;

&lt;strong&gt;double asterisks&lt;/strong&gt;

&lt;strong&gt;double underscores&lt;/strong&gt;
</code></pre>

<p>你可以隨便用你喜歡的樣式，唯一的限制是，你用什麼符號開啟標籤，就要用什麼符號結束。</p>

<p>強調也可以直接插在文字中間：</p>

<pre><code>un*frigging*believable
</code></pre>

<p>但是如果你的 <code>*</code> 和 <code>_</code> 兩邊都有空白的話，它們就只會被當成普通的符號。</p>

<p>如果要在文字前後直接插入普通的星號或底線，你可以用反斜線：</p>

<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre>

<h3 id="code">程式碼</h3>


<p>如果要標記一小段行內程式碼，你可以用反引號把它包起來（<code>`</code>），例如：</p>

<pre><code>Use the `printf()` function.
</code></pre>

<p>會產生：</p>

<pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre>

<p>如果要在程式碼區段內插入反引號，你可以用多個反引號來開啟和結束程式碼區段：</p>

<pre><code>``There is a literal backtick (`) here.``
</code></pre>

<p>這段語法會產生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>程式碼區段的起始和結束端都可以放入一個空白，起始端後面一個，結束端前面一個，這樣你就可以在區段的一開始就插入反引號：</p>

<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre>

<p>會產生：</p>

<pre><code>&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>在程式碼區段內，<code>&amp;</code> 和方括號都會被轉成 HTML 實體，這樣會比較容易插入 HTML 原始碼，Markdown 會把下面這段：</p>

<pre><code>Please don't use any `&lt;blink&gt;` tags.
</code></pre>

<p>轉為：</p>

<pre><code>&lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre>

<p>你也可以這樣寫：</p>

<pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre>

<p>以產生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre>

<h3 id="img">圖片</h3>


<p>很明顯地，要在純文字應用中設計一個 「自然」的語法來插入圖片是有一定難度的。</p>

<p>Markdown 使用一種和連結很相似的語法來標記圖片，同樣也允許兩種樣式： <em>行內</em>和<em>參考</em>。</p>

<p>行內圖片的語法看起來像是：</p>

<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg "Optional title")
</code></pre>

<p>詳細敘述如下：</p>

<ul>
<li>一個驚嘆號 <code>!</code></li>
<li>接著一個方括號，裡面放上圖片的替代文字</li>
<li>接著一個普通括號，裡面放上圖片的網址，最後還可以用引號包住並加上
選擇性的 'title' 文字。</li>
</ul>


<p>參考式的圖片語法則長得像這樣：</p>

<pre><code>![Alt text][id]
</code></pre>

<p>「id」是圖片參考的名稱，圖片參考的定義方式則和連結參考一樣：</p>

<pre><code>[id]: url/to/image  "Optional title attribute"
</code></pre>

<p>到目前為止， Markdown 還沒有辦法指定圖片的寬高，如果你需要的話，你可以使用普通的 <code>&lt;img&gt;</code> 標籤。</p>

<hr />

<h2 id="misc">其它</h2>




<h3 id="autolink">自動連結</h3>


<p>Markdown 支援比較簡短的自動連結形式來處理網址和電子郵件信箱，只要是用方括號包起來， Markdown 就會自動把它轉成連結，連結的文字就和連結位置一樣，例如：</p>

<pre><code>&lt;http://example.com/&gt;
</code></pre>

<p>Markdown 會轉為：</p>

<pre><code>&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;
</code></pre>

<p>自動的郵件連結也很類似，只是 Markdown 會先做一個編碼轉換的過程，把文字字元轉成 16 進位碼的 HTML 實體，這樣的格式可以混淆一些不好的信箱地址收集機器人，例如：</p>

<pre><code>&lt;address@example.com&gt;
</code></pre>

<p>Markdown 會轉成：</p>

<pre><code>&lt;a href="&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre>

<p>在瀏覽器裡面，這段字串會變成一個可以點擊的「address@example.com」連結。</p>

<p>（這種作法雖然可以混淆不少的機器人，但並無法全部擋下來，不過這樣也比什麼都不做好些。無論如何，公開你的信箱終究會引來廣告信件的。）</p>

<h3 id="backslash">跳脫字元</h3>


<p>Markdown 可以利用反斜線來插入一些在語法中有其它意義的符號，例如：如果你想要用星號加在文字旁邊的方式來做出強調效果（但不用 <code>&lt;em&gt;</code> 標籤），你可以在星號的前面加上反斜線：</p>

<pre><code>\*literal asterisks\*
</code></pre>

<p>Markdown 支援在下面這些符號前面加上反斜線來幫助插入普通的符號：</p>

<pre><code>\   反斜線
`   反引號
*   星號
_   底線
{}  大括號
[]  方括號
()  括號
#   井字號
+   加號
-   減號
.   英文句點
!   驚嘆號
</code></pre>

<h2 id="acknowledgement">感謝</h2>


<p>感謝 <a href="https://twitter.com/#!/leafy7382">leafy7382</a> 協助翻譯，<a href="http://iamhlb.com/">hlb</a>、<a href="http://twitter.com/randylien">Randylien</a> 幫忙潤稿，<a href="https://twitter.com/#!/ethantw">ethantw</a> 的<a href="http://ethantw.net/projects/han/">漢字標準格式・CSS Reset</a>， <a href="http://kidwm.net/">WM</a> 回報文字錯誤。</p>
]]></content>
  </entry>
  
</feed>
