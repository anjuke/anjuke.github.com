
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Anjuke Engineering</title>
  <meta name="author" content="Anjuke Inc.">

  
  <meta name="description" content="本文涉及PHP V2代码级SDK设计的规范。 代码 目录结构和命名 SDK的模块代码将和客户代码在同一个运行时环境下执行，代码的命名需要注意，避免名称冲突。 假设发布功能模块的SDK名称为($SDK_NAME)，其代码的根目录应该命名为:app-($SDK_NAME)-shared。 app-($ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://arch.corp.anjuke.com/blog/page/5/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Anjuke Engineering" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-38932031-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Anjuke Engineering</a></h1>
  
    <h2>技术成就梦想</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:arch.corp.anjuke.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="https://github.com/anjuke">Code</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/01/16/php-v2-sdk/">PHP V2 SDK 设计规范</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-16T16:27:00+08:00" pubdate data-updated="true">Jan 16<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文涉及PHP V2代码级SDK设计的规范。</p>

<h2>代码</h2>

<h3>目录结构和命名</h3>

<p>SDK的模块代码将和客户代码在同一个运行时环境下执行，代码的命名需要注意，避免名称冲突。</p>

<p>假设发布功能模块的SDK名称为<code>($SDK_NAME)</code>，其代码的根目录应该命名为:<code>app-($SDK_NAME)-shared</code>。</p>

<pre><code>app-($SDK_NAME)-shared
|
+--- classes
|    |    
|    +--- $(SDK_NAME)
|    |    |
|    |    + API.php
|    |
|    + ...
|
+--- config
|    |
|    +--- database.php
|    |
|    +--- common.php
|    |
|    + ...
|
+--- lib
</code></pre>

<p>对使用SDK的客户代码，只需要关心一个类<code>($SDK_NAME)_API</code>，类文件位于<code>classes/($SDK_NAME)/API.php</code>。
客户代码在需要调用模块的地方引用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="nx">apf_require_class</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{</span><span class="nv">$SDK_NAME</span><span class="si">}</span><span class="s2">_API&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nv">$api</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$SDK_NAME</span><span class="p">)</span><span class="nx">_API</span><span class="o">::</span><span class="na">get_instance</span><span class="p">();</span>
</span><span class='line'><span class="nv">$api</span><span class="o">-&gt;</span><span class="na">exported_func</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>API文件的基本格式为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="nx">apf_require_class</span><span class="p">(</span><span class="s1">&#39;....&#39;</span><span class="p">);</span>
</span><span class='line'><span class="nx">apf_require_class</span><span class="p">(</span><span class="s1">&#39;....&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="err">($</span><span class="nc">SDK_NAME</span><span class="p">)</span><span class="nx">_API</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="no">VERSION</span> <span class="o">=</span> <span class="s1">&#39;....&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">get_instance</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">exported_func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2012/01/16/php-v2-sdk/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/01/07/semver/">版本号的语义命名法 2.0.0-rc.1</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-07T16:27:00+08:00" pubdate data-updated="true">Jan 7<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>翻译: <a href="http://git.corp.anjuke.com/cgit/jizhang/semver.git/">jizhang</a></p>

<p>在软件管理过程中，随着系统规模的扩大，会有越来越多的模块被加入进来，包与包之间的依赖关系往往会让我们陷入痛苦的境地。</p>

<p>当系统中有很多依赖关系存在时，发布新版本的包会成为一场恶梦。如果依赖过于紧密，就可能会产生“版本锁”，即发布包的新版本时需要发布其依赖包的新版本；如果依赖关系很松散，这样还是会陷入混乱，因为需要对更多的包进行兼容。这些问题往往会成为项目向前推进的绊脚石。</p>

<p>为了解决这个问题，我拟定了一组简单的规则，用来规范软件发布中的版本号命名。在实施这组规则之前，我们需要一套API接口。这个接口可以是一组文档，也可以是代码实现。最重要的是，这套API接口必须是明确和精准的。在确认了这套API接口之后，对它的任何改动都要通过特定的版本号递增规则来进行。假设版本号的格式为X.Y.Z（主版本.次版本.补丁）。修复Bug会递增补丁版本，向前兼容的API修改或新增功能会递增次版本，向前不兼容的API修改会递增主版本。</p>

<p>我给这套规则起名为“版本号的语义命名法”。在这种规则下，版本号的递增过程是带有特定含义的。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2012/01/07/semver/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/30/gitcorp-faq/">GitCorp FAQ</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-30T14:12:00+08:00" pubdate data-updated="true">Dec 30<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="/blog/2012/04/24/gitcorp-faq/">FAQ更新，请访问新地址</a></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/12/30/gitcorp-faq/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/28/multi-string-search/">多关键字的文本精确匹配搜索</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-28T22:22:00+08:00" pubdate data-updated="true">Nov 28<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>基本的要求是对给定的一个文本块进行关键字匹配，进行匹配的关键字是多个，而且可能非常多(成千上万)，然后输出各个匹配到的关键字的位置。这可用用作关键字的高亮显示，当然也可用进行敏感词过滤。</p>

<p>参考linux命令行<code>fgrep</code></p>

<h2>功能</h2>

<p>输入一段文本，输出匹配到的关键字在输入文本中的位置。</p>

<p>例如，关键词列表：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 关键字    类型(可选)
</span><span class='line'>安居客      公司名称
</span><span class='line'>二手房      通用名词</span></code></pre></td></tr></table></div></figure>


<p>待查询文本为：</p>

<blockquote><p><em>安居客，是安居客集团旗下国内最大的专业二手房网站。自2007年上线至今的短短4年时间里，安居客凭借其“专业二手房搜索引擎”的核心竞争力在业内独树一帜。通过对用户需求的精准把握、海量的二手房房源、精准的搜索功能、强大的产品研发能力，为用户提供最佳找房体验。目前，安居客的足迹已经遍布全国超过29个城市，注册用户超过1000万。</em></p></blockquote>

<p>输出结果为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[
</span><span class='line'>  (安居客, 公司名称, 0),
</span><span class='line'>  (二手房, 通用名词, 69),
</span><span class='line'>  (安居客, 公司名称, 134),
</span><span class='line'>  (二手房, 通用名词, 161),
</span><span class='line'>  (二手房, 通用名词, 275),
</span><span class='line'>  (安居客, 公司名称, 392)
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/11/28/multi-string-search/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/03/hanzi-to-pinyin/">汉字转拼音服务规范</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-03T22:22:00+08:00" pubdate data-updated="true">Nov 3<span>rd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我们希望安居客的搜索引擎能够更好的做到同音字的容错，采用拼音容错是一个不错的方法。因此，需要一个将汉字转换为拼音的组件。同时，汉字转拼音组件还可以有多个用途，例如以拼音的首字母来检索小区名、人名等。</p>

<p>这样我们需要一个通用的将汉字转换为拼音的服务。</p>

<h2>功能</h2>

<p>基本功能就是中文拉丁化，输入一段中文文本，输出转变为汉语拼音的文本。</p>

<p>要求原文中的全角标点符号、空格等应该转为对应的半脚符号。原汉字与英文间如果没有空格分隔，转换为拼音后应该加入空格分隔。</p>

<p>例如，“<strong>我的英文名是Bob。</strong>” 转化后为&#8217;<strong>wo de ying wen ming shi Bob.</strong>&#8217;</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/11/03/hanzi-to-pinyin/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/09/zguide-cn-chapter5/">ZMQ 指南 - 第五章 高级发布-订阅模式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-09T22:22:00+08:00" pubdate data-updated="true">Oct 9<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>作者: Pieter Hintjens <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x70;&#x68;&#64;&#105;&#109;&#97;&#x74;&#105;&#120;&#x2e;&#99;&#111;&#109;">&#x70;&#x68;&#x40;&#x69;&#109;&#97;&#x74;&#x69;&#x78;&#46;&#x63;&#x6f;&#109;</a>, CEO iMatix Corporation.</strong>
<strong>翻译: 张吉 <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#106;&#105;&#122;&#104;&#x61;&#110;&#x67;&#x40;&#97;&#x6e;&#x6a;&#x75;&#107;&#101;&#46;&#99;&#x6f;&#109;">&#x6a;&#105;&#122;&#104;&#x61;&#110;&#103;&#x40;&#x61;&#x6e;&#x6a;&#117;&#x6b;&#x65;&#46;&#x63;&#111;&#109;</a>, 安居客集团 好租网工程师</strong></p>

<p>第三章和第四章讲述了ZMQ中请求-应答模式的一些高级用法。如果你已经能够彻底理解了，那我要说声恭喜。这一章我们会关注发布-订阅模式，使用上层模式封装，提升ZMQ发布-订阅模式的性能、可靠性、状态同步及安全机制。</p>

<p>本章涉及的内容有：</p>

<ul>
<li>处理慢订阅者（自杀的蜗牛模式）</li>
<li>高速订阅者（黑箱模式）</li>
<li>构建一个共享键值缓存（克隆模式）</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/10/09/zguide-cn-chapter5/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/09/zguide-cn-chapter4/">ZMQ 指南 - 第四章 可靠的请求-应答模式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-09T22:22:00+08:00" pubdate data-updated="true">Oct 9<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>作者: Pieter Hintjens <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x70;&#104;&#x40;&#x69;&#109;&#97;&#116;&#105;&#120;&#46;&#x63;&#x6f;&#x6d;">&#x70;&#x68;&#64;&#x69;&#109;&#x61;&#x74;&#105;&#x78;&#x2e;&#x63;&#x6f;&#x6d;</a>, CEO iMatix Corporation.</strong>
<strong>翻译: 张吉 <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#106;&#105;&#x7a;&#104;&#x61;&#110;&#103;&#x40;&#x61;&#x6e;&#106;&#117;&#107;&#101;&#46;&#99;&#x6f;&#x6d;">&#x6a;&#105;&#122;&#104;&#x61;&#x6e;&#103;&#x40;&#x61;&#x6e;&#106;&#117;&#x6b;&#101;&#x2e;&#99;&#x6f;&#109;</a>, 安居客集团 好租网工程师</strong></p>

<p>第三章中我们使用实例介绍了高级请求-应答模式，本章我们会讲述请求-应答模式的可靠性问题，并使用ZMQ提供的套接字类型组建起可靠的请求-应答消息系统。</p>

<p>本章将介绍的内容有：</p>

<ul>
<li>客户端请求-应答</li>
<li>最近最少使用队列</li>
<li>心跳机制</li>
<li>面向服务的队列</li>
<li>基于磁盘（脱机）队列</li>
<li>主从备份服务</li>
<li>无中间件的请求-应答</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/10/09/zguide-cn-chapter4/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/09/zguide-cn-chapter3/">ZMQ 指南 - 第三章 高级请求-应答模式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-09T22:22:00+08:00" pubdate data-updated="true">Oct 9<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>作者: Pieter Hintjens <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#112;&#104;&#64;&#105;&#x6d;&#97;&#x74;&#x69;&#x78;&#x2e;&#99;&#111;&#x6d;">&#112;&#x68;&#x40;&#x69;&#109;&#97;&#116;&#105;&#x78;&#x2e;&#99;&#111;&#x6d;</a>, CEO iMatix Corporation.</strong>
<strong>翻译: 张吉 <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x6a;&#x69;&#x7a;&#x68;&#97;&#x6e;&#103;&#x40;&#x61;&#x6e;&#106;&#x75;&#107;&#x65;&#46;&#99;&#x6f;&#109;">&#x6a;&#105;&#122;&#x68;&#x61;&#x6e;&#x67;&#x40;&#97;&#x6e;&#106;&#x75;&#x6b;&#101;&#46;&#99;&#x6f;&#x6d;</a>, 安居客集团 好租网工程师</strong></p>

<p>在第二章中我们通过开发一系列的小应用来熟悉ØMQ的基本使用方法，每个应用会引入一些新的特性。本章会沿用这种方式，来探索更多建立在ØMQ请求-应答模式之上的高级工作模式。</p>

<p>本章涉及的内容有：</p>

<ul>
<li>在请求-应答模式中创建和使用消息信封</li>
<li>使用REQ、REP、DEALER和ROUTER套接字</li>
<li>使用标识来手工指定应答目标</li>
<li>使用自定义离散路由模式</li>
<li>使用自定义最近最少使用路由模式</li>
<li>构建高层消息封装类</li>
<li>构建基本的请求应答代理</li>
<li>合理命名套接字</li>
<li>模拟client-worker集群</li>
<li>构建可扩展的请求-应答集群云</li>
<li>使用管道套接字监控线程</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/10/09/zguide-cn-chapter3/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/09/zguide-cn-chapter2/">ZMQ 指南 - 第二章 ZeroMQ进阶</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-09T22:22:00+08:00" pubdate data-updated="true">Oct 9<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>作者: Pieter Hintjens <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#112;&#x68;&#x40;&#x69;&#x6d;&#x61;&#x74;&#105;&#x78;&#x2e;&#99;&#111;&#109;">&#112;&#x68;&#64;&#x69;&#109;&#97;&#x74;&#105;&#120;&#x2e;&#x63;&#111;&#109;</a>, CEO iMatix Corporation.</strong>
<strong>翻译: 张吉 <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#106;&#105;&#122;&#x68;&#97;&#110;&#103;&#x40;&#97;&#110;&#x6a;&#117;&#107;&#x65;&#46;&#99;&#x6f;&#x6d;">&#106;&#105;&#x7a;&#104;&#97;&#x6e;&#103;&#64;&#97;&#110;&#x6a;&#x75;&#x6b;&#x65;&#46;&#x63;&#x6f;&#109;</a>, 安居客集团 好租网工程师</strong></p>

<p>第一章我们简单试用了ZMQ的若干通信模式：请求-应答模式、发布-订阅模式、管道模式。这一章我们将学习更多在实际开发中会使用到的东西：</p>

<p>本章涉及的内容有：</p>

<ul>
<li>创建和使用ZMQ套接字</li>
<li>使用套接字发送和接收消息</li>
<li>使用ZMQ提供的异步I/O套接字构建你的应用程序</li>
<li>在单一线程中使用多个套接字</li>
<li>恰当地处理致命和非致命错误</li>
<li>处理诸如Ctrl-C的中断信号</li>
<li>正确地关闭ZMQ应用程序</li>
<li>检查ZMQ应用程序的内存泄露</li>
<li>发送和接收多帧消息</li>
<li>在网络中转发消息</li>
<li>建立简单的消息队列代理</li>
<li>使用ZMQ编写多线程应用程序</li>
<li>使用ZMQ在线程间传递信号</li>
<li>使用ZMQ协调网络中的节点</li>
<li>使用标识创建持久化套接字</li>
<li>在发布-订阅模式中创建和使用消息信封</li>
<li>如何让持久化的订阅者能够从崩溃中恢复</li>
<li>使用阈值（HWM）防止内存溢出</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/10/09/zguide-cn-chapter2/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/09/zguide-cn-chapter1/">ZMQ 指南 - 第一章 ZeroMQ基础</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-09T22:22:00+08:00" pubdate data-updated="true">Oct 9<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>作者: Pieter Hintjens <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x70;&#104;&#x40;&#x69;&#109;&#x61;&#x74;&#x69;&#x78;&#x2e;&#x63;&#111;&#109;">&#x70;&#104;&#x40;&#x69;&#109;&#x61;&#x74;&#105;&#x78;&#46;&#x63;&#111;&#x6d;</a>, CEO iMatix Corporation.</strong>
<strong>翻译: 张吉 <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#106;&#105;&#122;&#104;&#97;&#x6e;&#x67;&#x40;&#x61;&#x6e;&#x6a;&#117;&#x6b;&#x65;&#46;&#x63;&#111;&#x6d;">&#106;&#x69;&#122;&#x68;&#x61;&#x6e;&#x67;&#64;&#x61;&#x6e;&#x6a;&#x75;&#107;&#101;&#x2e;&#99;&#111;&#x6d;</a>, 安居客集团 好租网工程师</strong></p>

<p>With thanks to Bill Desmarais, Brian Dorsey, CAF, Daniel Lin, Eric Desgranges, Gonzalo Diethelm, Guido Goldstein, Hunter Ford, Kamil Shakirov, Martin Sustrik, Mike Castleman, Naveen Chawla, Nicola Peduzzi, Oliver Smith, Olivier Chamoux, Peter Alexander, Pierre Rouleau, Randy Dryburgh, John Unwin, Alex Thomas, Mihail Minkov, Jeremy Avnet, Michael Compton, Kamil Kisiel, Mark Kharitonov, Guillaume Aubert, Ian Barber, Mike Sheridan, Faruk Akgul, Oleg Sidorov, Lev Givon, Allister MacLeod, Alexander D&#8217;Archangel, Andreas Hoelzlwimmer, Han Holl, Robert G. Jakabosky, Felipe Cruz, Marcus McCurdy, Mikhail Kulemin, Dr. Gergő Érdi, Pavel Zhukov, Alexander Else, Giovanni Ruggiero, Rick &#8220;Technoweenie&#8221;, Daniel Lundin, Dave Hoover, Simon Jefford, Benjamin Peterson, Justin Case, Devon Weller, Richard Smith, Alexander Morland, Wadim Grasza, Michael Jakl, and Zed Shaw for their contributions, and to Stathis Sideris for <a href="http://www.ditaa.org">Ditaa</a>.</p>

<p>Please use the <a href="https://github.com/imatix/zguide/issues">issue tracker</a> for all comments and errata. This version covers the latest stable release of 0MQ and was published on Mon 10 October, 2011.</p>

<p>The Guide is mainly <a href="http://zguide.zeromq.org/page:all">in C</a>, but also in <a href="http://zguide.zeromq.org/php:all">PHP</a> and <a href="http://zguide.zeromq.org/lua:all">Lua</a>.</p>

<hr />

<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 License</a>.</p>

<h3>拯救世界</h3>

<p>如何解释ZMQ？有些人会先说一堆ZMQ的好：它是一套用于快速构建的套接字组件；它的信箱系统有超强的路由能力；它太快了！而有些人则喜欢分享他们被ZMQ点悟的时刻，那些被灵感击中的瞬间：所有的事情突然变得简单明了，让人大开眼界。另一些人则会拿ZMQ同其他产品做个比较：它更小，更简单，但却让人觉得如此熟悉。对于我个人而言，我则更倾向于和别人分享ZMQ的诞生史，相信会和各位读者有所共鸣。</p>

<p>编程是一门科学，但往往会乔装成一门艺术。我们从不去了解软件最底层的机理，或者说根本没有人在乎这些。软件并不只是算法、数据结构、编程语言、或者抽象云云，这些不过是一些工具而已，被我们创造、使用、最后抛弃。软件真正的本质，其实是人的本质。</p>

<p>举例来说，当我们遇到一个高度复杂的问题时，我们会群策群力，分工合作，将问题拆分为若干个部分，一起解决。这里就体现了编程的科学：创建一组小型的构建模块，让人们易于理解和使用，那么大家就会一起用它来解决问题。</p>

<p>我们生活在一个普遍联系的世界里，需要现代的编程软件为我们做指引。所以，未来我们所需要的用于处理大规模计算的构建模块，必须是普遍联系的，而且能够并行运作。那时，程序代码不能再只关注自己，它们需要互相交流，变得足够健谈。程序代码需要像人脑一样，数以兆计的神经元高速地传输信号，在一个没有中央控制的环境下，没有单点故障的环境下，解决问题。这一点其实并不意外，因为就当今的网络来讲，每个节点其实就像是连接了一个人脑一样。</p>

<p>如果你曾和线程、协议、或网络打过交道，你会觉得我上面的话像是天方夜谭。因为在实际应用过程中，只是连接几个程序或网络就已经非常困难和麻烦了。数以兆计的节点？那真是无法想象的。现今只有资金雄厚的企业才能负担得起这种软件和服务。</p>

<p>当今世界的网络结构已经远远超越了我们自身的驾驭能力。十九世纪八十年代的软件危机，弗莱德•布鲁克斯曾说过，这个世上<a href="http://en.wikipedia.org/wiki/No_Silver_Bullet">没有银弹</a>。后来，免费和开源解决了这次软件危机，让我们能够高效地分享知识。如今，我们又面临一次新的软件危机，只不过我们谈论得不多。只有那些大型的、富足的企业才有财力建立高度联系的应用程序。那里有云的存在，但它是私有的。我们的数据和知识正在从我们的个人电脑中消失，流入云端，无法获得或与其竞争。是谁坐拥我们的社交网络？这真像一次巨型主机的革命。</p>

<p>我们暂且不谈其中的政治因素，光那些就可以另外出本书了。目前的现状是，虽然互联网能够让千万个程序相连，但我们之中的大多数却无法做到这些。这样一来，那些真正有趣的大型问题（如健康、教育、经济、交通等领域），仍然无法解决。我们没有能力将代码连接起来，也就不能像大脑中的神经元一样处理那些大规模的问题。</p>

<p>已经有人尝试用各种方法来连接应用程序，如数以千计的IETF规范，每种规范解决一个特定问题。对于开发人员来说，HTTP协议是比较简单和易用的，但这也往往让问题变得更糟，因为它鼓励人们形成一种重服务端、轻客户端的思想。</p>

<p>所以迄今为止人们还在使用原始的TCP/UDP协议、私有协议、HTTP协议、网络套接字等形式连接应用程序。这种做法依旧让人痛苦，速度慢又不易扩展，需要集中化管理。而分布式的P2P协议又仅仅适用于娱乐，而非真正的应用。有谁会使用Skype或者Bittorrent来交换数据呢？</p>

<p>这就让我们回归到编程科学的问题上来。想要拯救这个世界，我们需要做两件事情：一，如何在任何地点连接任何两个应用程序；二、将这个解决方案用最为简单的方式包装起来，供程序员使用。</p>

<p>也许这听起来太简单了，但事实确实如此。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/10/09/zguide-cn-chapter1/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/6/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/4/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/04/09/beautiful-computer-programming/">Beautiful Computer Programming</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/28/perl-prime-in-action-jvm-monitoring-2/">Perl入门实战：JVM监控脚本（下）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/27/fork-and-zombie-process/">fork()与僵尸进程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/26/perl-prime-in-action-jvm-monitoring-1/">Perl入门实战：JVM监控脚本（上）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/07/currying-and-partial-application/">柯里化与偏应用（JavaScript描述）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/01/using-pypi-provided-by-anjuke/">使用安居客提供的PyPI镜像</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/09/cia-hadoop/">Clojure实战(4)：编写Hadoop MapReduce脚本</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/20/homebrew-is-just-like-gentoo-portage/">Homebrew is just like gentoo portage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/04/clojure-style-guide/">Clojure 代码规范</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/23/nginx-live-upgrade/">Nginx热升级</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/anjuke">@anjuke</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'anjuke',
            count: 10,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Anjuke Inc. -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'archcorp';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
